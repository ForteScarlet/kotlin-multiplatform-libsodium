(function (_, Kotlin, $module$bignum) {
  'use strict';
  var $$importsForInline$$ = _.$$importsForInline$$ || (_.$$importsForInline$$ = {});
  var Kind_OBJECT = Kotlin.Kind.OBJECT;
  var chunked = Kotlin.kotlin.collections.chunked_ba2ldo$;
  var joinToString = Kotlin.kotlin.collections.joinToString_fmv235$;
  var println = Kotlin.kotlin.io.println_s8jyv4$;
  var toString = Kotlin.kotlin.text.toString_aogav3$;
  var toString_0 = Kotlin.kotlin.text.toString_hc3rh$;
  var defineInlineFunction = Kotlin.defineInlineFunction;
  var wrapFunction = Kotlin.wrapFunction;
  var RuntimeException_init = Kotlin.kotlin.RuntimeException_init_pdl1vj$;
  var chunked_0 = Kotlin.kotlin.text.chunked_94bcnn$;
  var toUByte = Kotlin.kotlin.text.toUByte_6ic1pp$;
  var UInt = Kotlin.kotlin.UInt;
  var joinToString_0 = Kotlin.kotlin.collections.joinToString_cgipc5$;
  var toString_1 = Kotlin.kotlin.text.toString_dqglrj$;
  var ArrayList_init = Kotlin.kotlin.collections.ArrayList_init_ww73n8$;
  var ULong_init = Kotlin.kotlin.ULong;
  var UByte_init = Kotlin.kotlin.UByte;
  var toByte = Kotlin.toByte;
  var copyToArray = Kotlin.kotlin.collections.copyToArray;
  var collectionSizeOrDefault = Kotlin.kotlin.collections.collectionSizeOrDefault_ba2ldo$;
  var uintCompare = Kotlin.kotlin.uintCompare_vux9f0$;
  var Kind_INTERFACE = Kotlin.Kind.INTERFACE;
  var encodeToByteArray = Kotlin.kotlin.text.encodeToByteArray_pdl1vz$;
  var toList = Kotlin.kotlin.collections.toList_7wnvza$;
  var toBigInteger = $module$bignum.com.ionspin.kotlin.bignum.integer.toBigInteger_s8ev3n$;
  var toList_0 = Kotlin.kotlin.collections.toList_us0mfu$;
  var IllegalStateException_init = Kotlin.kotlin.IllegalStateException_init_pdl1vj$;
  var until = Kotlin.kotlin.ranges.until_dqglrj$;
  var BigInteger = $module$bignum.com.ionspin.kotlin.bignum.integer.BigInteger;
  var Kind_CLASS = Kotlin.Kind.CLASS;
  var Array_0 = Array;
  var L255 = Kotlin.Long.fromInt(255);
  var emptyList = Kotlin.kotlin.collections.emptyList_287e2$;
  var slice = Kotlin.kotlin.collections.slice_l0m14x$;
  var arrayCopy = Kotlin.kotlin.collections.arrayCopy;
  var ArrayList_init_0 = Kotlin.kotlin.collections.ArrayList_init_287e2$;
  var addAll = Kotlin.kotlin.collections.addAll_ipc267$;
  var copyOfRange = Kotlin.kotlin.collections.copyOfRange_5f8l3u$;
  var UByteArray = Kotlin.kotlin.UByteArray;
  var flatten = Kotlin.kotlin.collections.flatten_yrqxlj$;
  var get_indices = Kotlin.kotlin.collections.get_indices_m7z4lg$;
  var println_0 = Kotlin.kotlin.io.println;
  var uintDivide = Kotlin.kotlin.uintDivide_oqfnby$;
  var uintRemainder = Kotlin.kotlin.uintRemainder_oqfnby$;
  var reversed = Kotlin.kotlin.collections.reversed_7wnvza$;
  var last = Kotlin.kotlin.collections.last_2p1efm$;
  var last_0 = Kotlin.kotlin.collections.last_us0mfu$;
  var dropLast = Kotlin.kotlin.collections.dropLast_8ujjk8$;
  var dropLast_0 = Kotlin.kotlin.collections.dropLast_yzln2o$;
  var reversed_0 = Kotlin.kotlin.collections.reversed_us0mfu$;
  var List = Kotlin.kotlin.collections.List;
  var throwCCE = Kotlin.throwCCE;
  var toTypedArray = Kotlin.kotlin.collections.toTypedArray_o5f02i$;
  var contentEquals = Kotlin.arrayEquals;
  var contentHashCode = Kotlin.arrayHashCode;
  var ModularBigInteger = $module$bignum.com.ionspin.kotlin.bignum.modular.ModularBigInteger;
  var Endianness = $module$bignum.com.ionspin.kotlin.bignum.Endianness;
  var Enum = Kotlin.kotlin.Enum;
  var throwISE = Kotlin.throwISE;
  AesKey$Aes128Key.prototype = Object.create(AesKey.prototype);
  AesKey$Aes128Key.prototype.constructor = AesKey$Aes128Key;
  AesKey$Aes192Key.prototype = Object.create(AesKey.prototype);
  AesKey$Aes192Key.prototype.constructor = AesKey$Aes192Key;
  AesKey$Aes256Key.prototype = Object.create(AesKey.prototype);
  AesKey$Aes256Key.prototype.constructor = AesKey$Aes256Key;
  Mode.prototype = Object.create(Enum.prototype);
  Mode.prototype.constructor = Mode;
  function Config() {
    Config_instance = this;
    this.DEBUG = false;
  }
  Config.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'Config',
    interfaces: []
  };
  var Config_instance = null;
  function Config_getInstance() {
    if (Config_instance === null) {
      new Config();
    }
    return Config_instance;
  }
  function hexColumsPrint$lambda$lambda(it) {
    return it.toUpperCase();
  }
  function hexColumsPrint($receiver) {
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(toString_1(item, 16));
    }
    var printout = chunked(destination, 16);
    var tmp$_0;
    tmp$_0 = printout.iterator();
    while (tmp$_0.hasNext()) {
      var element = tmp$_0.next();
      println(joinToString(element, ' ', void 0, void 0, void 0, void 0, hexColumsPrint$lambda$lambda));
    }
  }
  function hexColumsPrint$lambda$lambda_0(it) {
    return it.toUpperCase();
  }
  function hexColumsPrint_0($receiver) {
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(toString(item, 16));
    }
    var printout = chunked(destination, 16);
    var tmp$_0;
    tmp$_0 = printout.iterator();
    while (tmp$_0.hasNext()) {
      var element = tmp$_0.next();
      println(joinToString(element, ' ', void 0, void 0, void 0, void 0, hexColumsPrint$lambda$lambda_0));
    }
  }
  function hexColumsPrint$lambda$lambda_1(it) {
    return it.toUpperCase();
  }
  function hexColumsPrint_1($receiver) {
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(toString_0(item, 16));
    }
    var printout = chunked(destination, 3);
    var tmp$_0;
    tmp$_0 = printout.iterator();
    while (tmp$_0.hasNext()) {
      var element = tmp$_0.next();
      println(joinToString(element, ' ', void 0, void 0, void 0, void 0, hexColumsPrint$lambda$lambda_1));
    }
  }
  var chunked_1 = defineInlineFunction('multiplatform-crypto.com.ionspin.kotlin.crypto.chunked_r20n03$', wrapFunction(function () {
    var emptyList = Kotlin.kotlin.collections.emptyList_287e2$;
    var wrapFunction = Kotlin.wrapFunction;
    var until = Kotlin.kotlin.ranges.until_dqglrj$;
    var slice = Kotlin.kotlin.collections.slice_l0m14x$;
    var ArrayList_init = Kotlin.kotlin.collections.ArrayList_init_ww73n8$;
    var collectionSizeOrDefault = Kotlin.kotlin.collections.collectionSizeOrDefault_ba2ldo$;
    var copyToArray = Kotlin.kotlin.collections.copyToArray;
    var chunked$lambda = wrapFunction(function () {
      var copyToArray = Kotlin.kotlin.collections.copyToArray;
      return function (it) {
        return copyToArray(it);
      };
    });
    return function (T_0, isT, $receiver, sliceSize) {
      var last = $receiver.length % sliceSize;
      var hasLast = last !== 0;
      var numberOfSlices = $receiver.length / sliceSize | 0;
      var list = ArrayList_init(0);
      for (var index = 0; index < 0; index++) {
        list.add_11rb$(emptyList());
      }
      var result = list;
      for (var i = 0; i < numberOfSlices; i++) {
        result.add_11rb$(slice($receiver, until(Kotlin.imul(i, sliceSize), Kotlin.imul(i + 1 | 0, sliceSize))));
      }
      if (hasLast) {
        result.add_11rb$(slice($receiver, until(Kotlin.imul(numberOfSlices, sliceSize), $receiver.length)));
      }
      var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
      var tmp$;
      tmp$ = result.iterator();
      while (tmp$.hasNext()) {
        var item = tmp$.next();
        destination.add_11rb$(copyToArray(item));
      }
      return copyToArray(destination);
    };
  }));
  function rotateRight($receiver, places) {
    var tmp$ = new UInt($receiver.data >>> places);
    var bitCount = 32 - places | 0;
    var other = new UInt($receiver.data << bitCount);
    return new UInt(tmp$.data ^ other.data);
  }
  function rotateRight_0($receiver, places) {
    var tmp$ = new ULong_init($receiver.data.shiftRightUnsigned(places));
    var bitCount = 64 - places | 0;
    var other = new ULong_init($receiver.data.shiftLeft(bitCount));
    return new ULong_init(tmp$.data.xor(other.data));
  }
  function xor($receiver, other) {
    if ($receiver.length !== other.length) {
      throw RuntimeException_init('Operands of different sizes are not supported yet');
    }
    var $receiver_0 = $receiver.slice();
    var destination = ArrayList_init($receiver_0.length);
    var tmp$, tmp$_0;
    var index = 0;
    for (tmp$ = 0; tmp$ !== $receiver_0.length; ++tmp$) {
      var item = $receiver_0[tmp$];
      var tmp$_1 = destination.add_11rb$;
      var other_0 = other[tmp$_0 = index, index = tmp$_0 + 1 | 0, tmp$_0];
      tmp$_1.call(destination, new UByte_init(toByte(item.data ^ other_0.data)));
    }
    return copyToArray(destination);
  }
  function hexStringToUByteArray($receiver) {
    var $receiver_0 = chunked_0($receiver, 2);
    var destination = ArrayList_init(collectionSizeOrDefault($receiver_0, 10));
    var tmp$;
    tmp$ = $receiver_0.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      destination.add_11rb$(toUByte(item, 16));
    }
    return copyToArray(destination);
  }
  function toHexString$lambda(it) {
    var other = new UInt(15);
    if (uintCompare((new UInt(it.data & 255)).data, other.data) <= 0) {
      return '0' + toString(it, 16);
    }
     else {
      return toString(it, 16);
    }
  }
  function toHexString($receiver) {
    return joinToString_0($receiver, '', void 0, void 0, void 0, void 0, toHexString$lambda);
  }
  function Hash() {
  }
  Hash.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'Hash',
    interfaces: []
  };
  function UpdatableHash() {
  }
  UpdatableHash.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'UpdatableHash',
    interfaces: [Hash]
  };
  function StatelessHash() {
  }
  StatelessHash.prototype.digest_5pksov$ = function (inputString, key, hashLength, callback$default) {
    if (key === void 0)
      key = null;
    if (hashLength === void 0)
      hashLength = this.MAX_HASH_BYTES;
    return callback$default ? callback$default(inputString, key, hashLength) : this.digest_5pksov$$default(inputString, key, hashLength);
  };
  StatelessHash.prototype.digest_o2z9gi$ = function (inputMessage, key, hashLength, callback$default) {
    if (inputMessage === void 0) {
      inputMessage = [];
    }
    if (key === void 0) {
      key = [];
    }
    if (hashLength === void 0)
      hashLength = this.MAX_HASH_BYTES;
    return callback$default ? callback$default(inputMessage, key, hashLength) : this.digest_o2z9gi$$default(inputMessage, key, hashLength);
  };
  StatelessHash.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'StatelessHash',
    interfaces: [Hash]
  };
  var chunked$lambda = wrapFunction(function () {
    var copyToArray = Kotlin.kotlin.collections.copyToArray;
    return function (it) {
      return copyToArray(it);
    };
  });
  function Blake2b(key, hashLength) {
    Blake2b$Companion_getInstance();
    if (key === void 0)
      key = null;
    if (hashLength === void 0)
      hashLength = 64;
    this.key = key;
    this.hashLength = hashLength;
    this.MAX_HASH_BYTES_b5cfdo$_0 = Blake2b$Companion_getInstance().MAX_HASH_BYTES;
    this.h = Blake2b$Companion_getInstance().iv_0.slice();
    this.counter = BigInteger.Companion.ZERO;
    this.bufferCounter = 0;
    var array = Array_0(128);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    for (var i = 0; i <= tmp$; i++) {
      array[i] = new UByte_init(0);
    }
    this.buffer = array;
    var tmp$_0, tmp$_1, tmp$_2, tmp$_3;
    var $this = this.h[0];
    var other = new ULong_init(Kotlin.Long.fromInt(16842752));
    tmp$_3 = new ULong_init($this.data.xor(other.data));
    tmp$_2 = (tmp$_1 = (tmp$_0 = this.key) != null ? new ULong_init((new ULong_init(Kotlin.Long.fromInt(tmp$_0.length))).data.shiftLeft(8)) : null) != null ? tmp$_1 : new ULong_init(Kotlin.Long.ZERO);
    var tmp$_4 = this.h;
    var tmp$_5 = new ULong_init(tmp$_3.data.xor(tmp$_2.data));
    var $receiver = this.hashLength;
    var other_0 = new ULong_init(Kotlin.Long.fromInt($receiver));
    tmp$_4[0] = new ULong_init(tmp$_5.data.xor(other_0.data));
    var $receiver_0 = this.key;
    var tmp$_6 = $receiver_0 == null;
    if (!tmp$_6) {
      tmp$_6 = $receiver_0.length === 0;
    }
    if (!tmp$_6) {
      this.appendToBuffer_0(Blake2b$Companion_getInstance().padToBlock_0(this.key), this.bufferCounter);
    }
  }
  function Blake2b$Companion() {
    Blake2b$Companion_instance = this;
    this.BITS_IN_WORD = 64;
    this.ROUNDS_IN_COMPRESS = 12;
    this.BLOCK_BYTES = 128;
    this.MAX_HASH_BYTES_kbpvc6$_0 = 64;
    this.MIN_HASH_BYTES = 1;
    this.MAX_KEY_BYTES = 64;
    this.MIN_KEY_BYTES = 0;
    this.MAX_INPUT_BYTES = toBigInteger(2).shl_za3lpa$(128);
    this.sigma_0 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3], [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4], [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8], [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13], [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9], [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11], [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10], [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5], [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0]];
    this.iv_0 = [new ULong_init(new Kotlin.Long(-205731576, 1779033703)), new ULong_init(new Kotlin.Long(-2067093701, -1150833019)), new ULong_init(new Kotlin.Long(-23791573, 1013904242)), new ULong_init(new Kotlin.Long(1595750129, -1521486534)), new ULong_init(new Kotlin.Long(-1377402159, 1359893119)), new ULong_init(new Kotlin.Long(725511199, -1694144372)), new ULong_init(new Kotlin.Long(-79577749, 528734635)), new ULong_init(new Kotlin.Long(327033209, 1541459225))];
    this.R1 = 32;
    this.R2 = 24;
    this.R3 = 16;
    this.R4 = 63;
  }
  Object.defineProperty(Blake2b$Companion.prototype, 'MAX_HASH_BYTES', {
    get: function () {
      return this.MAX_HASH_BYTES_kbpvc6$_0;
    }
  });
  Blake2b$Companion.prototype.mixRound_r29y2p$ = function (input, message, round) {
    var v = input;
    var selectedSigma = this.sigma_0[round % 10];
    v = this.mix_0(v, 0, 4, 8, 12, message[selectedSigma[0]], message[selectedSigma[1]]);
    v = this.mix_0(v, 1, 5, 9, 13, message[selectedSigma[2]], message[selectedSigma[3]]);
    v = this.mix_0(v, 2, 6, 10, 14, message[selectedSigma[4]], message[selectedSigma[5]]);
    v = this.mix_0(v, 3, 7, 11, 15, message[selectedSigma[6]], message[selectedSigma[7]]);
    v = this.mix_0(v, 0, 5, 10, 15, message[selectedSigma[8]], message[selectedSigma[9]]);
    v = this.mix_0(v, 1, 6, 11, 12, message[selectedSigma[10]], message[selectedSigma[11]]);
    v = this.mix_0(v, 2, 7, 8, 13, message[selectedSigma[12]], message[selectedSigma[13]]);
    v = this.mix_0(v, 3, 4, 9, 14, message[selectedSigma[14]], message[selectedSigma[15]]);
    return v;
  };
  Blake2b$Companion.prototype.mix_0 = function (v, a, b, c, d, x, y) {
    var $this = v[a];
    var other = v[b];
    v[a] = new ULong_init((new ULong_init($this.data.add(other.data))).data.add(x.data));
    var $this_0 = v[d];
    var other_0 = v[a];
    v[d] = rotateRight_0(new ULong_init($this_0.data.xor(other_0.data)), 32);
    var $this_1 = v[c];
    var other_1 = v[d];
    v[c] = new ULong_init($this_1.data.add(other_1.data));
    var $this_2 = v[b];
    var other_2 = v[c];
    v[b] = rotateRight_0(new ULong_init($this_2.data.xor(other_2.data)), 24);
    var $this_3 = v[a];
    var other_3 = v[b];
    v[a] = new ULong_init((new ULong_init($this_3.data.add(other_3.data))).data.add(y.data));
    var $this_4 = v[d];
    var other_4 = v[a];
    v[d] = rotateRight_0(new ULong_init($this_4.data.xor(other_4.data)), 16);
    var $this_5 = v[c];
    var other_5 = v[d];
    v[c] = new ULong_init($this_5.data.add(other_5.data));
    var $this_6 = v[b];
    var other_6 = v[c];
    v[b] = rotateRight_0(new ULong_init($this_6.data.xor(other_6.data)), 63);
    return v;
  };
  function Blake2b$Companion$compress$lambda$lambda(it) {
    return it.toUpperCase();
  }
  Blake2b$Companion.prototype.compress_c1cv33$ = function (h, input, offsetCounter, finalBlock) {
    var array = Array_0(16);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    for (var i = 0; i <= tmp$; i++) {
      var init$result;
      if (i >= 0 && i <= 7) {
        init$result = h[i];
      }
       else {
        init$result = this.iv_0[i - 8 | 0];
      }
      array[i] = init$result;
    }
    var v = array;
    var array_0 = Array_0(16);
    var tmp$_0;
    tmp$_0 = array_0.length - 1 | 0;
    for (var i_0 = 0; i_0 <= tmp$_0; i_0++) {
      array_0[i_0] = new ULong_init(Kotlin.Long.ZERO);
    }
    var tmp$_1, tmp$_0_0;
    var index = 0;
    var accumulator = array_0;
    for (tmp$_1 = 0; tmp$_1 !== input.length; ++tmp$_1) {
      var element = input[tmp$_1];
      var index_0 = (tmp$_0_0 = index, index = tmp$_0_0 + 1 | 0, tmp$_0_0);
      var acc = accumulator;
      var slot = index_0 / 8 | 0;
      var position = index_0 % 8;
      var tmp$_2 = acc[slot];
      var $this = new ULong_init(Kotlin.Long.fromInt(element.data).and(L255));
      var bitCount = position * 8 | 0;
      var other = new ULong_init($this.data.shiftLeft(bitCount));
      acc[slot] = new ULong_init(tmp$_2.data.add(other.data));
      accumulator = acc;
    }
    var m = accumulator;
    if (Config_getInstance().DEBUG) {
      var destination = ArrayList_init(m.length);
      var tmp$_3;
      for (tmp$_3 = 0; tmp$_3 !== m.length; ++tmp$_3) {
        var item = m[tmp$_3];
        destination.add_11rb$(toString_0(item, 16));
      }
      var printout = chunked(destination, 4);
      var tmp$_4;
      tmp$_4 = printout.iterator();
      while (tmp$_4.hasNext()) {
        var element_0 = tmp$_4.next();
        println(joinToString(element_0, ' ', void 0, void 0, void 0, void 0, Blake2b$Companion$compress$lambda$lambda));
      }
      println('Offset ' + offsetCounter);
    }
    var $this_0 = v[12];
    var other_0 = offsetCounter.ulongValue_6taknv$();
    v[12] = new ULong_init($this_0.data.xor(other_0.data));
    var $this_1 = v[13];
    var other_1 = offsetCounter.shr_za3lpa$(64).ulongValue_6taknv$();
    v[13] = new ULong_init($this_1.data.xor(other_1.data));
    if (finalBlock) {
      v[14] = new ULong_init(v[14].data.inv());
    }
    for (var i_1 = 0; i_1 < 12; i_1++) {
      this.mixRound_r29y2p$(v, m, i_1);
    }
    for (var i_2 = 0; i_2 <= 7; i_2++) {
      var $this_2 = h[i_2];
      var other_2 = v[i_2];
      var $this_3 = new ULong_init($this_2.data.xor(other_2.data));
      var other_3 = v[i_2 + 8 | 0];
      h[i_2] = new ULong_init($this_3.data.xor(other_3.data));
    }
    return h;
  };
  Blake2b$Companion.prototype.digest_5pksov$$default = function (inputString, key, hashLength) {
    var tmp$;
    var $receiver = encodeToByteArray(inputString);
    var destination = ArrayList_init($receiver.length);
    var tmp$_0;
    for (tmp$_0 = 0; tmp$_0 !== $receiver.length; ++tmp$_0) {
      var item = $receiver[tmp$_0];
      destination.add_11rb$(new UByte_init(item));
    }
    var array = copyToArray(toList(destination));
    var tmp$_1;
    if (key != null) {
      var $receiver_0 = encodeToByteArray(key);
      var destination_0 = ArrayList_init($receiver_0.length);
      var tmp$_2;
      for (tmp$_2 = 0; tmp$_2 !== $receiver_0.length; ++tmp$_2) {
        var item_0 = $receiver_0[tmp$_2];
        destination_0.add_11rb$(new UByte_init(item_0));
      }
      tmp$_1 = copyToArray(destination_0);
    }
     else
      tmp$_1 = null;
    var keyBytes = (tmp$ = tmp$_1) != null ? tmp$ : [];
    return this.digest_o2z9gi$(array, keyBytes);
  };
  Blake2b$Companion.prototype.digest_o2z9gi$$default = function (inputMessage, key, hashLength) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2;
    var last = inputMessage.length % 128;
    var hasLast = last !== 0;
    var numberOfSlices = inputMessage.length / 128 | 0;
    var list = ArrayList_init(0);
    for (var index = 0; index < 0; index++) {
      list.add_11rb$(emptyList());
    }
    var result = list;
    for (var i = 0; i < numberOfSlices; i++) {
      result.add_11rb$(slice(inputMessage, until(Kotlin.imul(i, 128), Kotlin.imul(i + 1 | 0, 128))));
    }
    if (hasLast) {
      result.add_11rb$(slice(inputMessage, until(Kotlin.imul(numberOfSlices, 128), inputMessage.length)));
    }
    var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
    var tmp$_3;
    tmp$_3 = result.iterator();
    while (tmp$_3.hasNext()) {
      var item = tmp$_3.next();
      destination.add_11rb$(copyToArray(item));
    }
    var chunkedMessage = copyToArray(destination);
    var h = this.iv_0.slice();
    var $this = h[0];
    var other = new ULong_init(Kotlin.Long.fromInt(16842752));
    var tmp$_4 = new ULong_init($this.data.xor(other.data));
    var other_0 = new ULong_init((new ULong_init(Kotlin.Long.fromInt(key.length))).data.shiftLeft(8));
    var tmp$_5 = new ULong_init(tmp$_4.data.xor(other_0.data));
    var other_1 = new ULong_init(Kotlin.Long.fromInt(hashLength));
    h[0] = new ULong_init(tmp$_5.data.xor(other_1.data));
    if (key.length === 0) {
      if (chunkedMessage.length === 0) {
        var array = Array_0(1);
        var tmp$_6;
        tmp$_6 = array.length - 1 | 0;
        for (var i_0 = 0; i_0 <= tmp$_6; i_0++) {
          var array_0 = Array_0(128);
          var tmp$_7;
          tmp$_7 = array_0.length - 1 | 0;
          for (var i_1 = 0; i_1 <= tmp$_7; i_1++) {
            array_0[i_1] = new UByte_init(0);
          }
          array[i_0] = array_0;
        }
        tmp$ = array;
      }
       else {
        tmp$ = chunkedMessage;
      }
    }
     else {
      tmp$ = [this.padToBlock_0(key)].concat(chunkedMessage);
    }
    var message = tmp$;
    if (message.length > 1) {
      tmp$_0 = message.length - 1 | 0;
      for (var i_2 = 0; i_2 < tmp$_0; i_2++) {
        var $receiver = this.compress_c1cv33$(h, message[i_2], toBigInteger((i_2 + 1 | 0) * 128 | 0), false);
        arrayCopy($receiver, h, 0, 0, $receiver.length);
      }
    }
    switch (message.length) {
      case 0:
        tmp$_1 = 0;
        break;
      case 1:
        tmp$_1 = message[message.length - 1 | 0].length;
        break;
      default:tmp$_1 = ((message.length - 1 | 0) * 128 | 0) + message[message.length - 1 | 0].length | 0;
        break;
    }
    var lastSize = tmp$_1;
    if (!(message.length === 0)) {
      tmp$_2 = this.padToBlock_0(message[message.length - 1 | 0]);
    }
     else {
      var array_1 = Array_0(16);
      var tmp$_8;
      tmp$_8 = array_1.length - 1 | 0;
      for (var i_3 = 0; i_3 <= tmp$_8; i_3++) {
        array_1[i_3] = new UByte_init(0);
      }
      tmp$_2 = array_1;
    }
    var lastBlockPadded = tmp$_2;
    var $receiver_0 = this.compress_c1cv33$(h, lastBlockPadded, toBigInteger(lastSize), true);
    arrayCopy($receiver_0, h, 0, 0, $receiver_0.length);
    return this.formatResult_0(h);
  };
  Blake2b$Companion.prototype.formatResult_0 = function (h) {
    var destination = ArrayList_init(h.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== h.length; ++tmp$) {
      var item = h[tmp$];
      var tmp$_0 = destination.add_11rb$;
      var other = new ULong_init(Kotlin.Long.fromInt(255));
      var tmp$_1 = new UByte_init(toByte((new ULong_init(item.data.and(other.data))).data.toInt()));
      var $this = new ULong_init(item.data.shiftRightUnsigned(8));
      var other_0 = new ULong_init(Kotlin.Long.fromInt(255));
      var tmp$_2 = new UByte_init(toByte((new ULong_init($this.data.and(other_0.data))).data.toInt()));
      var $this_0 = new ULong_init(item.data.shiftRightUnsigned(16));
      var other_1 = new ULong_init(Kotlin.Long.fromInt(255));
      var tmp$_3 = new UByte_init(toByte((new ULong_init($this_0.data.and(other_1.data))).data.toInt()));
      var $this_1 = new ULong_init(item.data.shiftRightUnsigned(24));
      var other_2 = new ULong_init(Kotlin.Long.fromInt(255));
      var tmp$_4 = new UByte_init(toByte((new ULong_init($this_1.data.and(other_2.data))).data.toInt()));
      var $this_2 = new ULong_init(item.data.shiftRightUnsigned(32));
      var other_3 = new ULong_init(Kotlin.Long.fromInt(255));
      var tmp$_5 = new UByte_init(toByte((new ULong_init($this_2.data.and(other_3.data))).data.toInt()));
      var $this_3 = new ULong_init(item.data.shiftRightUnsigned(40));
      var other_4 = new ULong_init(Kotlin.Long.fromInt(255));
      var tmp$_6 = new UByte_init(toByte((new ULong_init($this_3.data.and(other_4.data))).data.toInt()));
      var $this_4 = new ULong_init(item.data.shiftRightUnsigned(48));
      var other_5 = new ULong_init(Kotlin.Long.fromInt(255));
      var tmp$_7 = new UByte_init(toByte((new ULong_init($this_4.data.and(other_5.data))).data.toInt()));
      var $this_5 = new ULong_init(item.data.shiftRightUnsigned(56));
      var other_6 = new ULong_init(Kotlin.Long.fromInt(255));
      tmp$_0.call(destination, [tmp$_1, tmp$_2, tmp$_3, tmp$_4, tmp$_5, tmp$_6, tmp$_7, new UByte_init(toByte((new ULong_init($this_5.data.and(other_6.data))).data.toInt()))]);
    }
    var destination_0 = ArrayList_init_0();
    var tmp$_8;
    tmp$_8 = destination.iterator();
    while (tmp$_8.hasNext()) {
      var element = tmp$_8.next();
      var list = toList_0(element);
      addAll(destination_0, list);
    }
    return copyToArray(destination_0);
  };
  Blake2b$Companion.prototype.padToBlock_0 = function (unpadded) {
    if (unpadded.length === 128) {
      return unpadded;
    }
    if (unpadded.length > 128) {
      throw IllegalStateException_init('Block larger than 128 bytes');
    }
    var array = Array_0(128);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    for (var i = 0; i <= tmp$; i++) {
      var init$result;
      if (0 <= i && i < unpadded.length) {
        init$result = unpadded[i];
      }
       else {
        init$result = new UByte_init(0);
      }
      array[i] = init$result;
    }
    return array;
  };
  Blake2b$Companion.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'Companion',
    interfaces: [StatelessHash]
  };
  var Blake2b$Companion_instance = null;
  function Blake2b$Companion_getInstance() {
    if (Blake2b$Companion_instance === null) {
      new Blake2b$Companion();
    }
    return Blake2b$Companion_instance;
  }
  Object.defineProperty(Blake2b.prototype, 'MAX_HASH_BYTES', {
    get: function () {
      return this.MAX_HASH_BYTES_b5cfdo$_0;
    }
  });
  Blake2b.prototype.update_ummv9a$ = function (data) {
    if (data.length === 0) {
      throw RuntimeException_init('Updating with empty array is not allowed. If you need empty hash, just call digest without updating');
    }
    if ((this.bufferCounter + data.length | 0) < 128)
      this.appendToBuffer_0(data, this.bufferCounter);
    else if ((this.bufferCounter + data.length | 0) >= 128) {
      var last = data.length % 128;
      var hasLast = last !== 0;
      var numberOfSlices = data.length / 128 | 0;
      var list = ArrayList_init(0);
      for (var index = 0; index < 0; index++) {
        list.add_11rb$(emptyList());
      }
      var result = list;
      for (var i = 0; i < numberOfSlices; i++) {
        result.add_11rb$(slice(data, until(Kotlin.imul(i, 128), Kotlin.imul(i + 1 | 0, 128))));
      }
      if (hasLast) {
        result.add_11rb$(slice(data, until(Kotlin.imul(numberOfSlices, 128), data.length)));
      }
      var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
      var tmp$;
      tmp$ = result.iterator();
      while (tmp$.hasNext()) {
        var item = tmp$.next();
        destination.add_11rb$(copyToArray(item));
      }
      var chunked = copyToArray(destination);
      var tmp$_0;
      for (tmp$_0 = 0; tmp$_0 !== chunked.length; ++tmp$_0) {
        var element = chunked[tmp$_0];
        if ((this.bufferCounter + element.length | 0) < 128) {
          this.appendToBuffer_0(element, this.bufferCounter);
        }
         else {
          arrayCopy(element, this.buffer, this.bufferCounter, 0, 128 - this.bufferCounter | 0);
          this.counter = this.counter.plus_za3lpa$(128);
          this.consumeBlock_0(this.buffer);
          var array = Array_0(128);
          var tmp$_1;
          tmp$_1 = array.length - 1 | 0;
          for (var i_0 = 0; i_0 <= tmp$_1; i_0++) {
            var init$result;
            var tmp$_2;
            tmp$_2 = element.length - (128 - this.bufferCounter) | 0;
            if (0 <= i_0 && i_0 < tmp$_2) {
              init$result = element[i_0 + (128 - this.bufferCounter) | 0];
            }
             else {
              init$result = new UByte_init(0);
            }
            array[i_0] = init$result;
          }
          this.buffer = array;
          this.bufferCounter = element.length - (128 - this.bufferCounter) | 0;
        }
      }
    }
  };
  Blake2b.prototype.update_61zpoe$ = function (data) {
    var $receiver = encodeToByteArray(data);
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(new UByte_init(item));
    }
    this.update_ummv9a$(copyToArray(destination));
  };
  Blake2b.prototype.appendToBuffer_0 = function (array, start) {
    arrayCopy(array, this.buffer, start, 0, array.length);
    this.bufferCounter = this.bufferCounter + array.length | 0;
  };
  Blake2b.prototype.consumeBlock_0 = function (block) {
    this.h = Blake2b$Companion_getInstance().compress_c1cv33$(this.h, block, this.counter, false);
  };
  Blake2b.prototype.digest = function () {
    var lastBlockPadded = Blake2b$Companion_getInstance().padToBlock_0(this.buffer);
    this.counter = this.counter.plus_za3lpa$(this.bufferCounter);
    Blake2b$Companion_getInstance().compress_c1cv33$(this.h, lastBlockPadded, this.counter, true);
    var result = Blake2b$Companion_getInstance().formatResult_0(this.h);
    this.reset_0();
    return result;
  };
  Blake2b.prototype.digestString = function () {
    var $receiver = this.digest();
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(toString(item, 16));
    }
    return joinToString(destination, '');
  };
  Blake2b.prototype.reset_0 = function () {
    this.h = Blake2b$Companion_getInstance().iv_0.slice();
    this.counter = BigInteger.Companion.ZERO;
    this.bufferCounter = 0;
    var array = Array_0(128);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    for (var i = 0; i <= tmp$; i++) {
      array[i] = new UByte_init(0);
    }
    this.buffer = array;
  };
  Blake2b.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'Blake2b',
    interfaces: [UpdatableHash]
  };
  function Blake2b_init(key, requestedHashLenght, $this) {
    if (requestedHashLenght === void 0)
      requestedHashLenght = 64;
    $this = $this || Object.create(Blake2b.prototype);
    var tmp$, tmp$_0, tmp$_1;
    var tmp$_2;
    if ((tmp$ = key != null ? encodeToByteArray(key) : null) != null) {
      var destination = ArrayList_init(tmp$.length);
      var tmp$_3;
      for (tmp$_3 = 0; tmp$_3 !== tmp$.length; ++tmp$_3) {
        var item = tmp$[tmp$_3];
        destination.add_11rb$(new UByte_init(item));
      }
      tmp$_2 = destination;
    }
     else
      tmp$_2 = null;
    Blake2b.call($this, (tmp$_1 = (tmp$_0 = tmp$_2) != null ? copyToArray(tmp$_0) : null) != null ? tmp$_1 : [], requestedHashLenght);
    return $this;
  }
  var chunked$lambda_0 = wrapFunction(function () {
    var copyToArray = Kotlin.kotlin.collections.copyToArray;
    return function (it) {
      return copyToArray(it);
    };
  });
  function Sha256() {
    Sha256$Companion_getInstance();
    this.MAX_HASH_BYTES_mqxonl$_0 = 32;
    this.h = Sha256$Companion_getInstance().iv.slice();
    this.counter = 0;
    this.bufferCounter = 0;
    var array = Array_0(64);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    for (var i = 0; i <= tmp$; i++) {
      array[i] = new UByte_init(0);
    }
    this.buffer = array;
  }
  Object.defineProperty(Sha256.prototype, 'MAX_HASH_BYTES', {
    get: function () {
      return this.MAX_HASH_BYTES_mqxonl$_0;
    }
  });
  function Sha256$Companion() {
    Sha256$Companion_instance = this;
    this.BLOCK_SIZE = 512;
    this.BLOCK_SIZE_IN_BYTES = 64;
    this.UINT_MASK = new UInt(-1);
    this.BYTE_MASK_FROM_ULONG = new ULong_init(Kotlin.Long.fromInt(255));
    this.BYTE_MASK_FROM_UINT = new UInt(255);
    this.MAX_HASH_BYTES_at6ood$_0 = 32;
    this.iv = [new UInt(1779033703), new UInt(-1150833019), new UInt(1013904242), new UInt(-1521486534), new UInt(1359893119), new UInt(-1694144372), new UInt(528734635), new UInt(1541459225)];
    this.k = [new UInt(1116352408), new UInt(1899447441), new UInt(-1245643825), new UInt(-373957723), new UInt(961987163), new UInt(1508970993), new UInt(-1841331548), new UInt(-1424204075), new UInt(-670586216), new UInt(310598401), new UInt(607225278), new UInt(1426881987), new UInt(1925078388), new UInt(-2132889090), new UInt(-1680079193), new UInt(-1046744716), new UInt(-459576895), new UInt(-272742522), new UInt(264347078), new UInt(604807628), new UInt(770255983), new UInt(1249150122), new UInt(1555081692), new UInt(1996064986), new UInt(-1740746414), new UInt(-1473132947), new UInt(-1341970488), new UInt(-1084653625), new UInt(-958395405), new UInt(-710438585), new UInt(113926993), new UInt(338241895), new UInt(666307205), new UInt(773529912), new UInt(1294757372), new UInt(1396182291), new UInt(1695183700), new UInt(1986661051), new UInt(-2117940946), new UInt(-1838011259), new UInt(-1564481375), new UInt(-1474664885), new UInt(-1035236496), new UInt(-949202525), new UInt(-778901479), new UInt(-694614492), new UInt(-200395387), new UInt(275423344), new UInt(430227734), new UInt(506948616), new UInt(659060556), new UInt(883997877), new UInt(958139571), new UInt(1322822218), new UInt(1537002063), new UInt(1747873779), new UInt(1955562222), new UInt(2024104815), new UInt(-2067236844), new UInt(-1933114872), new UInt(-1866530822), new UInt(-1538233109), new UInt(-1090935817), new UInt(-965641998)];
  }
  Object.defineProperty(Sha256$Companion.prototype, 'MAX_HASH_BYTES', {
    get: function () {
      return this.MAX_HASH_BYTES_at6ood$_0;
    }
  });
  Sha256$Companion.prototype.digest_5pksov$$default = function (inputString, key, hashLength) {
    var tmp$, tmp$_0;
    var $receiver = encodeToByteArray(inputString);
    var destination = ArrayList_init($receiver.length);
    var tmp$_1;
    for (tmp$_1 = 0; tmp$_1 !== $receiver.length; ++tmp$_1) {
      var item = $receiver[tmp$_1];
      destination.add_11rb$(new UByte_init(item));
    }
    tmp$ = copyToArray(destination);
    var tmp$_2;
    if (key != null) {
      var $receiver_0 = encodeToByteArray(key);
      var destination_0 = ArrayList_init($receiver_0.length);
      var tmp$_3;
      for (tmp$_3 = 0; tmp$_3 !== $receiver_0.length; ++tmp$_3) {
        var item_0 = $receiver_0[tmp$_3];
        destination_0.add_11rb$(new UByte_init(item_0));
      }
      tmp$_2 = copyToArray(destination_0);
    }
     else
      tmp$_2 = null;
    return this.digest_o2z9gi$(tmp$, (tmp$_0 = tmp$_2) != null ? tmp$_0 : [], hashLength);
  };
  Sha256$Companion.prototype.digest_o2z9gi$$default = function (inputMessage, key, hashLength) {
    var h = {v: this.iv.slice()};
    var expansionArray = this.createExpansionArray_za3lpa$(inputMessage.length);
    var tmp$ = inputMessage.concat(expansionArray);
    var $receiver = inputMessage.length * 8 | 0;
    var elements = this.toPaddedByteArray_0(new ULong_init(Kotlin.Long.fromInt($receiver)));
    var $receiver_0 = tmp$.concat(elements);
    var last = $receiver_0.length % 64;
    var hasLast = last !== 0;
    var numberOfSlices = $receiver_0.length / 64 | 0;
    var list = ArrayList_init(0);
    for (var index = 0; index < 0; index++) {
      list.add_11rb$(emptyList());
    }
    var result = list;
    for (var i = 0; i < numberOfSlices; i++) {
      result.add_11rb$(slice($receiver_0, until(Kotlin.imul(i, 64), Kotlin.imul(i + 1 | 0, 64))));
    }
    if (hasLast) {
      result.add_11rb$(slice($receiver_0, until(Kotlin.imul(numberOfSlices, 64), $receiver_0.length)));
    }
    var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
    var tmp$_0;
    tmp$_0 = result.iterator();
    while (tmp$_0.hasNext()) {
      var item = tmp$_0.next();
      destination.add_11rb$(copyToArray(item));
    }
    var chunks = copyToArray(destination);
    var tmp$_1;
    for (tmp$_1 = 0; tmp$_1 !== chunks.length; ++tmp$_1) {
      var element = chunks[tmp$_1];
      var w = this.expandChunk_0(element);
      var $receiver_1 = this.mix_0(h.v, w);
      arrayCopy($receiver_1, h.v, 0, 0, $receiver_1.length);
    }
    var $receiver_2 = this.toPaddedByteArray_1(h.v[0]);
    var elements_0 = this.toPaddedByteArray_1(h.v[1]);
    var $receiver_3 = $receiver_2.concat(elements_0);
    var elements_1 = this.toPaddedByteArray_1(h.v[2]);
    var $receiver_4 = $receiver_3.concat(elements_1);
    var elements_2 = this.toPaddedByteArray_1(h.v[3]);
    var $receiver_5 = $receiver_4.concat(elements_2);
    var elements_3 = this.toPaddedByteArray_1(h.v[4]);
    var $receiver_6 = $receiver_5.concat(elements_3);
    var elements_4 = this.toPaddedByteArray_1(h.v[5]);
    var $receiver_7 = $receiver_6.concat(elements_4);
    var elements_5 = this.toPaddedByteArray_1(h.v[6]);
    var $receiver_8 = $receiver_7.concat(elements_5);
    var elements_6 = this.toPaddedByteArray_1(h.v[7]);
    var digest = $receiver_8.concat(elements_6);
    return digest;
  };
  Sha256$Companion.prototype.scheduleSigma0_0 = function (value) {
    var $this = rotateRight(value, 7);
    var other = rotateRight(value, 18);
    var tmp$ = new UInt($this.data ^ other.data);
    var other_0 = new UInt(value.data >>> 3);
    return new UInt(tmp$.data ^ other_0.data);
  };
  Sha256$Companion.prototype.scheduleSigma1_0 = function (value) {
    var $this = rotateRight(value, 17);
    var other = rotateRight(value, 19);
    var tmp$ = new UInt($this.data ^ other.data);
    var other_0 = new UInt(value.data >>> 10);
    return new UInt(tmp$.data ^ other_0.data);
  };
  Sha256$Companion.prototype.compressionSigma0_0 = function (a) {
    var $this = rotateRight(a, 2);
    var other = rotateRight(a, 13);
    var $this_0 = new UInt($this.data ^ other.data);
    var other_0 = rotateRight(a, 22);
    return new UInt($this_0.data ^ other_0.data);
  };
  Sha256$Companion.prototype.compressionSigma1_0 = function (e) {
    var $this = rotateRight(e, 6);
    var other = rotateRight(e, 11);
    var $this_0 = new UInt($this.data ^ other.data);
    var other_0 = rotateRight(e, 25);
    return new UInt($this_0.data ^ other_0.data);
  };
  Sha256$Companion.prototype.ch_0 = function (x, y, z) {
    var tmp$ = new UInt(x.data & y.data);
    var other = this.UINT_MASK;
    var other_0 = new UInt((new UInt(x.data ^ other.data)).data & z.data);
    return new UInt(tmp$.data ^ other_0.data);
  };
  Sha256$Companion.prototype.maj_0 = function (x, y, z) {
    var tmp$ = new UInt(x.data & y.data);
    var other = new UInt(x.data & z.data);
    var tmp$_0 = new UInt(tmp$.data ^ other.data);
    var other_0 = new UInt(y.data & z.data);
    return new UInt(tmp$_0.data ^ other_0.data);
  };
  Sha256$Companion.prototype.expandChunk_0 = function (chunk) {
    var array = Array_0(64);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    for (var i = 0; i <= tmp$; i++) {
      var init$result;
      if (0 <= i && i < 16) {
        var tmp$_0 = new UInt((new UInt(chunk[i * 4 | 0].data & 255)).data << 24);
        var other = new UInt((new UInt(chunk[(i * 4 | 0) + 1 | 0].data & 255)).data << 16);
        var tmp$_1 = new UInt(tmp$_0.data + other.data | 0);
        var other_0 = new UInt((new UInt(chunk[(i * 4 | 0) + 2 | 0].data & 255)).data << 8);
        var tmp$_2 = new UInt(tmp$_1.data + other_0.data | 0);
        var other_1 = new UInt(chunk[(i * 4 | 0) + 3 | 0].data & 255);
        var collected = new UInt(tmp$_2.data + other_1.data | 0);
        init$result = collected;
      }
       else {
        init$result = new UInt(0);
      }
      array[i] = init$result;
    }
    var w = array;
    for (var i_0 = 16; i_0 < 64; i_0++) {
      var s0 = this.scheduleSigma0_0(w[i_0 - 15 | 0]);
      var s1 = this.scheduleSigma1_0(w[i_0 - 2 | 0]);
      var $this = new UInt(w[i_0 - 16 | 0].data + s0.data | 0);
      var other_2 = w[i_0 - 7 | 0];
      w[i_0] = new UInt((new UInt($this.data + other_2.data | 0)).data + s1.data | 0);
    }
    return w;
  };
  Sha256$Companion.prototype.mix_0 = function (h, w) {
    var paramA = h[0];
    var paramB = h[1];
    var paramC = h[2];
    var paramD = h[3];
    var paramE = h[4];
    var paramF = h[5];
    var paramG = h[6];
    var paramH = h[7];
    for (var i = 0; i < 64; i++) {
      var s1 = this.compressionSigma1_0(paramE);
      var ch = this.ch_0(paramE, paramF, paramG);
      var $this = new UInt((new UInt(paramH.data + s1.data | 0)).data + ch.data | 0);
      var other = this.k[i];
      var $this_0 = new UInt($this.data + other.data | 0);
      var other_0 = w[i];
      var temp1 = new UInt($this_0.data + other_0.data | 0);
      var s0 = this.compressionSigma0_0(paramA);
      var maj = this.maj_0(paramA, paramB, paramC);
      var temp2 = new UInt(s0.data + maj.data | 0);
      paramH = paramG;
      paramG = paramF;
      paramF = paramE;
      paramE = new UInt(paramD.data + temp1.data | 0);
      paramD = paramC;
      paramC = paramB;
      paramB = paramA;
      paramA = new UInt(temp1.data + temp2.data | 0);
    }
    var $this_1 = h[0];
    var other_1 = paramA;
    h[0] = new UInt($this_1.data + other_1.data | 0);
    var $this_2 = h[1];
    var other_2 = paramB;
    h[1] = new UInt($this_2.data + other_2.data | 0);
    var $this_3 = h[2];
    var other_3 = paramC;
    h[2] = new UInt($this_3.data + other_3.data | 0);
    var $this_4 = h[3];
    var other_4 = paramD;
    h[3] = new UInt($this_4.data + other_4.data | 0);
    var $this_5 = h[4];
    var other_5 = paramE;
    h[4] = new UInt($this_5.data + other_5.data | 0);
    var $this_6 = h[5];
    var other_6 = paramF;
    h[5] = new UInt($this_6.data + other_6.data | 0);
    var $this_7 = h[6];
    var other_7 = paramG;
    h[6] = new UInt($this_7.data + other_7.data | 0);
    var $this_8 = h[7];
    var other_8 = paramH;
    h[7] = new UInt($this_8.data + other_8.data | 0);
    return h;
  };
  Sha256$Companion.prototype.createExpansionArray_za3lpa$ = function (originalSizeInBytes) {
    var tmp$;
    var originalMessageSizeInBits = originalSizeInBytes * 8 | 0;
    var expandedRemainderOf512 = (originalMessageSizeInBits + 64 + 1 | 0) % 512;
    if (expandedRemainderOf512 === 0)
      tmp$ = 0;
    else
      tmp$ = (512 - expandedRemainderOf512 | 0) / 8 | 0;
    var zeroAddAmount = tmp$;
    var array = Array_0(zeroAddAmount + 1 | 0);
    var tmp$_0;
    tmp$_0 = array.length - 1 | 0;
    for (var i = 0; i <= tmp$_0; i++) {
      var init$result;
      if (i === 0) {
        init$result = new UByte_init(-128);
      }
       else {
        init$result = new UByte_init(0);
      }
      array[i] = init$result;
    }
    var expansionArray = array;
    return expansionArray;
  };
  Sha256$Companion.prototype.toPaddedByteArray_0 = function ($receiver) {
    var byteMask = this.BYTE_MASK_FROM_ULONG;
    var array = Array_0(8);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    loop_label: for (var i = 0; i <= tmp$; i++) {
      var init$result;
      init$break: do {
        switch (i) {
          case 7:
            init$result = new UByte_init(toByte((new ULong_init($receiver.data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 6:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(8))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 5:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(16))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 4:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(24))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 3:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(32))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 2:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(40))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 1:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(48))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 0:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(54))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          default:throw RuntimeException_init('Invalid conversion');
        }
      }
       while (false);
      array[i] = init$result;
    }
    return array;
  };
  Sha256$Companion.prototype.toPaddedByteArray_1 = function ($receiver) {
    var byteMask = this.BYTE_MASK_FROM_UINT;
    var array = Array_0(4);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    loop_label: for (var i = 0; i <= tmp$; i++) {
      var init$result;
      init$break: do {
        switch (i) {
          case 3:
            init$result = new UByte_init(toByte((new UInt($receiver.data & byteMask.data)).data));
            break init$break;
          case 2:
            init$result = new UByte_init(toByte((new UInt((new UInt($receiver.data >>> 8)).data & byteMask.data)).data));
            break init$break;
          case 1:
            init$result = new UByte_init(toByte((new UInt((new UInt($receiver.data >>> 16)).data & byteMask.data)).data));
            break init$break;
          case 0:
            init$result = new UByte_init(toByte((new UInt((new UInt($receiver.data >>> 24)).data & byteMask.data)).data));
            break init$break;
          default:throw RuntimeException_init('Invalid conversion');
        }
      }
       while (false);
      array[i] = init$result;
    }
    return array;
  };
  Sha256$Companion.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'Companion',
    interfaces: [StatelessHash]
  };
  var Sha256$Companion_instance = null;
  function Sha256$Companion_getInstance() {
    if (Sha256$Companion_instance === null) {
      new Sha256$Companion();
    }
    return Sha256$Companion_instance;
  }
  Sha256.prototype.update_61zpoe$ = function (data) {
    var $receiver = encodeToByteArray(data);
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(new UByte_init(item));
    }
    return this.update_ummv9a$(copyToArray(destination));
  };
  Sha256.prototype.update_ummv9a$ = function (data) {
    if (data.length === 0) {
      throw RuntimeException_init('Updating with empty array is not allowed. If you need empty hash, just call digest without updating');
    }
    if ((this.bufferCounter + data.length | 0) < 64)
      this.appendToBuffer_0(data, this.bufferCounter);
    else if ((this.bufferCounter + data.length | 0) >= 64) {
      var last = data.length % 64;
      var hasLast = last !== 0;
      var numberOfSlices = data.length / 64 | 0;
      var list = ArrayList_init(0);
      for (var index = 0; index < 0; index++) {
        list.add_11rb$(emptyList());
      }
      var result = list;
      for (var i = 0; i < numberOfSlices; i++) {
        result.add_11rb$(slice(data, until(Kotlin.imul(i, 64), Kotlin.imul(i + 1 | 0, 64))));
      }
      if (hasLast) {
        result.add_11rb$(slice(data, until(Kotlin.imul(numberOfSlices, 64), data.length)));
      }
      var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
      var tmp$;
      tmp$ = result.iterator();
      while (tmp$.hasNext()) {
        var item = tmp$.next();
        destination.add_11rb$(copyToArray(item));
      }
      var chunked = copyToArray(destination);
      var tmp$_0;
      for (tmp$_0 = 0; tmp$_0 !== chunked.length; ++tmp$_0) {
        var element = chunked[tmp$_0];
        if ((this.bufferCounter + element.length | 0) < 64) {
          this.appendToBuffer_0(element, this.bufferCounter);
        }
         else {
          arrayCopy(element, this.buffer, this.bufferCounter, 0, 64 - this.bufferCounter | 0);
          this.counter = this.counter + 64 | 0;
          this.consumeBlock_0(this.buffer);
          var array = Array_0(64);
          var tmp$_1;
          tmp$_1 = array.length - 1 | 0;
          for (var i_0 = 0; i_0 <= tmp$_1; i_0++) {
            var init$result;
            var tmp$_2;
            tmp$_2 = element.length - (64 - this.bufferCounter) | 0;
            if (0 <= i_0 && i_0 < tmp$_2) {
              init$result = element[i_0 + (64 - this.bufferCounter) | 0];
            }
             else {
              init$result = new UByte_init(0);
            }
            array[i_0] = init$result;
          }
          this.buffer = array;
          this.bufferCounter = element.length - (64 - this.bufferCounter) | 0;
        }
      }
    }
  };
  Sha256.prototype.consumeBlock_0 = function (block) {
    var w = Sha256$Companion_getInstance().expandChunk_0(block);
    var $receiver = Sha256$Companion_getInstance().mix_0(this.h, w);
    arrayCopy($receiver, this.h, 0, 0, $receiver.length);
  };
  Sha256.prototype.digest = function () {
    var length = this.counter + this.bufferCounter | 0;
    var expansionArray = Sha256$Companion_getInstance().createExpansionArray_za3lpa$(length);
    var tmp$ = copyOfRange(this.buffer, 0, this.bufferCounter).concat(expansionArray);
    var tmp$_0 = Sha256$Companion_getInstance();
    var $receiver = length * 8 | 0;
    var elements = tmp$_0.toPaddedByteArray_0(new ULong_init(Kotlin.Long.fromInt($receiver)));
    var finalBlock = tmp$.concat(elements);
    var last = finalBlock.length % 64;
    var hasLast = last !== 0;
    var numberOfSlices = finalBlock.length / 64 | 0;
    var list = ArrayList_init(0);
    for (var index = 0; index < 0; index++) {
      list.add_11rb$(emptyList());
    }
    var result = list;
    for (var i = 0; i < numberOfSlices; i++) {
      result.add_11rb$(slice(finalBlock, until(Kotlin.imul(i, 64), Kotlin.imul(i + 1 | 0, 64))));
    }
    if (hasLast) {
      result.add_11rb$(slice(finalBlock, until(Kotlin.imul(numberOfSlices, 64), finalBlock.length)));
    }
    var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
    var tmp$_1;
    tmp$_1 = result.iterator();
    while (tmp$_1.hasNext()) {
      var item = tmp$_1.next();
      destination.add_11rb$(copyToArray(item));
    }
    var $receiver_0 = copyToArray(destination);
    var tmp$_2;
    for (tmp$_2 = 0; tmp$_2 !== $receiver_0.length; ++tmp$_2) {
      var element = $receiver_0[tmp$_2];
      this.consumeBlock_0(element);
    }
    var $receiver_1 = Sha256$Companion_getInstance().toPaddedByteArray_1(this.h[0]);
    var elements_0 = Sha256$Companion_getInstance().toPaddedByteArray_1(this.h[1]);
    var $receiver_2 = $receiver_1.concat(elements_0);
    var elements_1 = Sha256$Companion_getInstance().toPaddedByteArray_1(this.h[2]);
    var $receiver_3 = $receiver_2.concat(elements_1);
    var elements_2 = Sha256$Companion_getInstance().toPaddedByteArray_1(this.h[3]);
    var $receiver_4 = $receiver_3.concat(elements_2);
    var elements_3 = Sha256$Companion_getInstance().toPaddedByteArray_1(this.h[4]);
    var $receiver_5 = $receiver_4.concat(elements_3);
    var elements_4 = Sha256$Companion_getInstance().toPaddedByteArray_1(this.h[5]);
    var $receiver_6 = $receiver_5.concat(elements_4);
    var elements_5 = Sha256$Companion_getInstance().toPaddedByteArray_1(this.h[6]);
    var $receiver_7 = $receiver_6.concat(elements_5);
    var elements_6 = Sha256$Companion_getInstance().toPaddedByteArray_1(this.h[7]);
    var digest = $receiver_7.concat(elements_6);
    return digest;
  };
  Sha256.prototype.digestString = function () {
    var $receiver = this.digest();
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(toString(item, 16));
    }
    return joinToString(destination, '');
  };
  Sha256.prototype.appendToBuffer_0 = function (array, start) {
    arrayCopy(array, this.buffer, start, 0, array.length);
    this.bufferCounter = this.bufferCounter + array.length | 0;
  };
  Sha256.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'Sha256',
    interfaces: [UpdatableHash]
  };
  var chunked$lambda_1 = wrapFunction(function () {
    var copyToArray = Kotlin.kotlin.collections.copyToArray;
    return function (it) {
      return copyToArray(it);
    };
  });
  function Sha512() {
    Sha512$Companion_getInstance();
    this.MAX_HASH_BYTES_h6j4ni$_0 = 32;
    this.h = Sha512$Companion_getInstance().iv.slice();
    this.counter = 0;
    this.bufferCounter = 0;
    var array = Array_0(128);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    for (var i = 0; i <= tmp$; i++) {
      array[i] = new UByte_init(0);
    }
    this.buffer = array;
  }
  Object.defineProperty(Sha512.prototype, 'MAX_HASH_BYTES', {
    get: function () {
      return this.MAX_HASH_BYTES_h6j4ni$_0;
    }
  });
  function Sha512$Companion() {
    Sha512$Companion_instance = this;
    this.BLOCK_SIZE = 1024;
    this.BLOCK_SIZE_IN_BYTES = 128;
    this.CHUNK_SIZE = 80;
    this.ULONG_MASK = new ULong_init(Kotlin.Long.NEG_ONE);
    this.MAX_HASH_BYTES_1k9xu8$_0 = 32;
    this.k = [new ULong_init(new Kotlin.Long(-685199838, 1116352408)), new ULong_init(new Kotlin.Long(602891725, 1899447441)), new ULong_init(new Kotlin.Long(-330482897, -1245643825)), new ULong_init(new Kotlin.Long(-2121671748, -373957723)), new ULong_init(new Kotlin.Long(-213338824, 961987163)), new ULong_init(new Kotlin.Long(-1241133031, 1508970993)), new ULong_init(new Kotlin.Long(-1357295717, -1841331548)), new ULong_init(new Kotlin.Long(-630357736, -1424204075)), new ULong_init(new Kotlin.Long(-1560083902, -670586216)), new ULong_init(new Kotlin.Long(1164996542, 310598401)), new ULong_init(new Kotlin.Long(1323610764, 607225278)), new ULong_init(new Kotlin.Long(-704662302, 1426881987)), new ULong_init(new Kotlin.Long(-226784913, 1925078388)), new ULong_init(new Kotlin.Long(991336113, -2132889090)), new ULong_init(new Kotlin.Long(633803317, -1680079193)), new ULong_init(new Kotlin.Long(-815192428, -1046744716)), new ULong_init(new Kotlin.Long(-1628353838, -459576895)), new ULong_init(new Kotlin.Long(944711139, -272742522)), new ULong_init(new Kotlin.Long(-1953704523, 264347078)), new ULong_init(new Kotlin.Long(2007800933, 604807628)), new ULong_init(new Kotlin.Long(1495990901, 770255983)), new ULong_init(new Kotlin.Long(1856431235, 1249150122)), new ULong_init(new Kotlin.Long(-1119749164, 1555081692)), new ULong_init(new Kotlin.Long(-2096016459, 1996064986)), new ULong_init(new Kotlin.Long(-295247957, -1740746414)), new ULong_init(new Kotlin.Long(766784016, -1473132947)), new ULong_init(new Kotlin.Long(-1728372417, -1341970488)), new ULong_init(new Kotlin.Long(-1091629340, -1084653625)), new ULong_init(new Kotlin.Long(1034457026, -958395405)), new ULong_init(new Kotlin.Long(-1828018395, -710438585)), new ULong_init(new Kotlin.Long(-536640913, 113926993)), new ULong_init(new Kotlin.Long(168717936, 338241895)), new ULong_init(new Kotlin.Long(1188179964, 666307205)), new ULong_init(new Kotlin.Long(1546045734, 773529912)), new ULong_init(new Kotlin.Long(1522805485, 1294757372)), new ULong_init(new Kotlin.Long(-1651133473, 1396182291)), new ULong_init(new Kotlin.Long(-1951439906, 1695183700)), new ULong_init(new Kotlin.Long(1014477480, 1986661051)), new ULong_init(new Kotlin.Long(1206759142, -2117940946)), new ULong_init(new Kotlin.Long(344077627, -1838011259)), new ULong_init(new Kotlin.Long(1290863460, -1564481375)), new ULong_init(new Kotlin.Long(-1136513023, -1474664885)), new ULong_init(new Kotlin.Long(-789014639, -1035236496)), new ULong_init(new Kotlin.Long(106217008, -949202525)), new ULong_init(new Kotlin.Long(-688958952, -778901479)), new ULong_init(new Kotlin.Long(1432725776, -694614492)), new ULong_init(new Kotlin.Long(1467031594, -200395387)), new ULong_init(new Kotlin.Long(851169720, 275423344)), new ULong_init(new Kotlin.Long(-1194143544, 430227734)), new ULong_init(new Kotlin.Long(1363258195, 506948616)), new ULong_init(new Kotlin.Long(-544281703, 659060556)), new ULong_init(new Kotlin.Long(-509917016, 883997877)), new ULong_init(new Kotlin.Long(-976659869, 958139571)), new ULong_init(new Kotlin.Long(-482243893, 1322822218)), new ULong_init(new Kotlin.Long(2003034995, 1537002063)), new ULong_init(new Kotlin.Long(-692930397, 1747873779)), new ULong_init(new Kotlin.Long(1575990012, 1955562222)), new ULong_init(new Kotlin.Long(1125592928, 2024104815)), new ULong_init(new Kotlin.Long(-1578062990, -2067236844)), new ULong_init(new Kotlin.Long(442776044, -1933114872)), new ULong_init(new Kotlin.Long(593698344, -1866530822)), new ULong_init(new Kotlin.Long(-561857047, -1538233109)), new ULong_init(new Kotlin.Long(-1295615723, -1090935817)), new ULong_init(new Kotlin.Long(-479046869, -965641998)), new ULong_init(new Kotlin.Long(-366583396, -903397682)), new ULong_init(new Kotlin.Long(566280711, -779700025)), new ULong_init(new Kotlin.Long(-840897762, -354779690)), new ULong_init(new Kotlin.Long(-294727304, -176337025)), new ULong_init(new Kotlin.Long(1914138554, 116418474)), new ULong_init(new Kotlin.Long(-1563912026, 174292421)), new ULong_init(new Kotlin.Long(-1090974290, 289380356)), new ULong_init(new Kotlin.Long(320620315, 460393269)), new ULong_init(new Kotlin.Long(587496836, 685471733)), new ULong_init(new Kotlin.Long(1086792851, 852142971)), new ULong_init(new Kotlin.Long(365543100, 1017036298)), new ULong_init(new Kotlin.Long(-1676669620, 1126000580)), new ULong_init(new Kotlin.Long(-885112138, 1288033470)), new ULong_init(new Kotlin.Long(-60457430, 1501505948)), new ULong_init(new Kotlin.Long(987167468, 1607167915)), new ULong_init(new Kotlin.Long(1246189591, 1816402316))];
    this.iv = [new ULong_init(new Kotlin.Long(-205731576, 1779033703)), new ULong_init(new Kotlin.Long(-2067093701, -1150833019)), new ULong_init(new Kotlin.Long(-23791573, 1013904242)), new ULong_init(new Kotlin.Long(1595750129, -1521486534)), new ULong_init(new Kotlin.Long(-1377402159, 1359893119)), new ULong_init(new Kotlin.Long(725511199, -1694144372)), new ULong_init(new Kotlin.Long(-79577749, 528734635)), new ULong_init(new Kotlin.Long(327033209, 1541459225))];
  }
  Object.defineProperty(Sha512$Companion.prototype, 'MAX_HASH_BYTES', {
    get: function () {
      return this.MAX_HASH_BYTES_1k9xu8$_0;
    }
  });
  Sha512$Companion.prototype.digest_5pksov$$default = function (inputString, key, hashLength) {
    var tmp$, tmp$_0;
    var $receiver = encodeToByteArray(inputString);
    var destination = ArrayList_init($receiver.length);
    var tmp$_1;
    for (tmp$_1 = 0; tmp$_1 !== $receiver.length; ++tmp$_1) {
      var item = $receiver[tmp$_1];
      destination.add_11rb$(new UByte_init(item));
    }
    tmp$ = copyToArray(destination);
    var tmp$_2;
    if (key != null) {
      var $receiver_0 = encodeToByteArray(key);
      var destination_0 = ArrayList_init($receiver_0.length);
      var tmp$_3;
      for (tmp$_3 = 0; tmp$_3 !== $receiver_0.length; ++tmp$_3) {
        var item_0 = $receiver_0[tmp$_3];
        destination_0.add_11rb$(new UByte_init(item_0));
      }
      tmp$_2 = copyToArray(destination_0);
    }
     else
      tmp$_2 = null;
    return this.digest_o2z9gi$(tmp$, (tmp$_0 = tmp$_2) != null ? tmp$_0 : [], hashLength);
  };
  Sha512$Companion.prototype.digest_o2z9gi$$default = function (inputMessage, key, hashLength) {
    var h = {v: this.iv.slice()};
    var expansionArray = this.createExpansionArray_za3lpa$(inputMessage.length);
    var tmp$ = inputMessage.concat(expansionArray);
    var $receiver = inputMessage.length * 8 | 0;
    var elements = this.toPadded128BitByteArray_0(new ULong_init(Kotlin.Long.fromInt($receiver)));
    var $receiver_0 = tmp$.concat(elements);
    var last = $receiver_0.length % 128;
    var hasLast = last !== 0;
    var numberOfSlices = $receiver_0.length / 128 | 0;
    var list = ArrayList_init(0);
    for (var index = 0; index < 0; index++) {
      list.add_11rb$(emptyList());
    }
    var result = list;
    for (var i = 0; i < numberOfSlices; i++) {
      result.add_11rb$(slice($receiver_0, until(Kotlin.imul(i, 128), Kotlin.imul(i + 1 | 0, 128))));
    }
    if (hasLast) {
      result.add_11rb$(slice($receiver_0, until(Kotlin.imul(numberOfSlices, 128), $receiver_0.length)));
    }
    var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
    var tmp$_0;
    tmp$_0 = result.iterator();
    while (tmp$_0.hasNext()) {
      var item = tmp$_0.next();
      destination.add_11rb$(copyToArray(item));
    }
    var chunks = copyToArray(destination);
    var tmp$_1;
    for (tmp$_1 = 0; tmp$_1 !== chunks.length; ++tmp$_1) {
      var element = chunks[tmp$_1];
      var w = this.expandChunk_0(element);
      this.mix_0(h.v, w);
    }
    var $receiver_1 = this.toPaddedByteArray_0(h.v[0]);
    var elements_0 = this.toPaddedByteArray_0(h.v[1]);
    var $receiver_2 = $receiver_1.concat(elements_0);
    var elements_1 = this.toPaddedByteArray_0(h.v[2]);
    var $receiver_3 = $receiver_2.concat(elements_1);
    var elements_2 = this.toPaddedByteArray_0(h.v[3]);
    var $receiver_4 = $receiver_3.concat(elements_2);
    var elements_3 = this.toPaddedByteArray_0(h.v[4]);
    var $receiver_5 = $receiver_4.concat(elements_3);
    var elements_4 = this.toPaddedByteArray_0(h.v[5]);
    var $receiver_6 = $receiver_5.concat(elements_4);
    var elements_5 = this.toPaddedByteArray_0(h.v[6]);
    var $receiver_7 = $receiver_6.concat(elements_5);
    var elements_6 = this.toPaddedByteArray_0(h.v[7]);
    var digest = $receiver_7.concat(elements_6);
    return digest;
  };
  Sha512$Companion.prototype.scheduleSigma0_0 = function (value) {
    var $this = rotateRight_0(value, 1);
    var other = rotateRight_0(value, 8);
    var tmp$ = new ULong_init($this.data.xor(other.data));
    var other_0 = new ULong_init(value.data.shiftRightUnsigned(7));
    return new ULong_init(tmp$.data.xor(other_0.data));
  };
  Sha512$Companion.prototype.scheduleSigma1_0 = function (value) {
    var $this = rotateRight_0(value, 19);
    var other = rotateRight_0(value, 61);
    var tmp$ = new ULong_init($this.data.xor(other.data));
    var other_0 = new ULong_init(value.data.shiftRightUnsigned(6));
    return new ULong_init(tmp$.data.xor(other_0.data));
  };
  Sha512$Companion.prototype.compressionSigma0_0 = function (e) {
    var $this = rotateRight_0(e, 28);
    var other = rotateRight_0(e, 34);
    var $this_0 = new ULong_init($this.data.xor(other.data));
    var other_0 = rotateRight_0(e, 39);
    return new ULong_init($this_0.data.xor(other_0.data));
  };
  Sha512$Companion.prototype.compressionSigma1_0 = function (a) {
    var $this = rotateRight_0(a, 14);
    var other = rotateRight_0(a, 18);
    var $this_0 = new ULong_init($this.data.xor(other.data));
    var other_0 = rotateRight_0(a, 41);
    return new ULong_init($this_0.data.xor(other_0.data));
  };
  Sha512$Companion.prototype.ch_0 = function (x, y, z) {
    var tmp$ = new ULong_init(x.data.and(y.data));
    var other = this.ULONG_MASK;
    var other_0 = new ULong_init((new ULong_init(x.data.xor(other.data))).data.and(z.data));
    return new ULong_init(tmp$.data.xor(other_0.data));
  };
  Sha512$Companion.prototype.maj_0 = function (x, y, z) {
    var tmp$ = new ULong_init(x.data.and(y.data));
    var other = new ULong_init(x.data.and(z.data));
    var tmp$_0 = new ULong_init(tmp$.data.xor(other.data));
    var other_0 = new ULong_init(y.data.and(z.data));
    return new ULong_init(tmp$_0.data.xor(other_0.data));
  };
  Sha512$Companion.prototype.expandChunk_0 = function (chunk) {
    var array = Array_0(80);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    for (var i = 0; i <= tmp$; i++) {
      var init$result;
      if (0 <= i && i < 16) {
        var $this = chunk[i * 8 | 0];
        var tmp$_0 = new ULong_init((new ULong_init(Kotlin.Long.fromInt($this.data).and(L255))).data.shiftLeft(56));
        var $this_0 = chunk[(i * 8 | 0) + 1 | 0];
        var other = new ULong_init((new ULong_init(Kotlin.Long.fromInt($this_0.data).and(L255))).data.shiftLeft(48));
        var tmp$_1 = new ULong_init(tmp$_0.data.add(other.data));
        var $this_1 = chunk[(i * 8 | 0) + 2 | 0];
        var other_0 = new ULong_init((new ULong_init(Kotlin.Long.fromInt($this_1.data).and(L255))).data.shiftLeft(40));
        var tmp$_2 = new ULong_init(tmp$_1.data.add(other_0.data));
        var $this_2 = chunk[(i * 8 | 0) + 3 | 0];
        var other_1 = new ULong_init((new ULong_init(Kotlin.Long.fromInt($this_2.data).and(L255))).data.shiftLeft(32));
        var tmp$_3 = new ULong_init(tmp$_2.data.add(other_1.data));
        var $this_3 = chunk[(i * 8 | 0) + 4 | 0];
        var other_2 = new ULong_init((new ULong_init(Kotlin.Long.fromInt($this_3.data).and(L255))).data.shiftLeft(24));
        var tmp$_4 = new ULong_init(tmp$_3.data.add(other_2.data));
        var $this_4 = chunk[(i * 8 | 0) + 5 | 0];
        var other_3 = new ULong_init((new ULong_init(Kotlin.Long.fromInt($this_4.data).and(L255))).data.shiftLeft(16));
        var tmp$_5 = new ULong_init(tmp$_4.data.add(other_3.data));
        var $this_5 = chunk[(i * 8 | 0) + 6 | 0];
        var other_4 = new ULong_init((new ULong_init(Kotlin.Long.fromInt($this_5.data).and(L255))).data.shiftLeft(8));
        var tmp$_6 = new ULong_init(tmp$_5.data.add(other_4.data));
        var $this_6 = chunk[(i * 8 | 0) + 7 | 0];
        var other_5 = new ULong_init(Kotlin.Long.fromInt($this_6.data).and(L255));
        var collected = new ULong_init(tmp$_6.data.add(other_5.data));
        init$result = collected;
      }
       else {
        init$result = new ULong_init(Kotlin.Long.ZERO);
      }
      array[i] = init$result;
    }
    var w = array;
    for (var i_0 = 16; i_0 < 80; i_0++) {
      var s0 = this.scheduleSigma0_0(w[i_0 - 15 | 0]);
      var s1 = this.scheduleSigma1_0(w[i_0 - 2 | 0]);
      var $this_7 = new ULong_init(w[i_0 - 16 | 0].data.add(s0.data));
      var other_6 = w[i_0 - 7 | 0];
      w[i_0] = new ULong_init((new ULong_init($this_7.data.add(other_6.data))).data.add(s1.data));
    }
    return w;
  };
  Sha512$Companion.prototype.mix_0 = function (h, w) {
    var paramA = h[0];
    var paramB = h[1];
    var paramC = h[2];
    var paramD = h[3];
    var paramE = h[4];
    var paramF = h[5];
    var paramG = h[6];
    var paramH = h[7];
    for (var i = 0; i < 80; i++) {
      var s1 = this.compressionSigma1_0(paramE);
      var ch = this.ch_0(paramE, paramF, paramG);
      var $this = new ULong_init((new ULong_init(paramH.data.add(s1.data))).data.add(ch.data));
      var other = this.k[i];
      var $this_0 = new ULong_init($this.data.add(other.data));
      var other_0 = w[i];
      var temp1 = new ULong_init($this_0.data.add(other_0.data));
      var s0 = this.compressionSigma0_0(paramA);
      var maj = this.maj_0(paramA, paramB, paramC);
      var temp2 = new ULong_init(s0.data.add(maj.data));
      paramH = paramG;
      paramG = paramF;
      paramF = paramE;
      paramE = new ULong_init(paramD.data.add(temp1.data));
      paramD = paramC;
      paramC = paramB;
      paramB = paramA;
      paramA = new ULong_init(temp1.data.add(temp2.data));
    }
    var $this_1 = h[0];
    var other_1 = paramA;
    h[0] = new ULong_init($this_1.data.add(other_1.data));
    var $this_2 = h[1];
    var other_2 = paramB;
    h[1] = new ULong_init($this_2.data.add(other_2.data));
    var $this_3 = h[2];
    var other_3 = paramC;
    h[2] = new ULong_init($this_3.data.add(other_3.data));
    var $this_4 = h[3];
    var other_4 = paramD;
    h[3] = new ULong_init($this_4.data.add(other_4.data));
    var $this_5 = h[4];
    var other_5 = paramE;
    h[4] = new ULong_init($this_5.data.add(other_5.data));
    var $this_6 = h[5];
    var other_6 = paramF;
    h[5] = new ULong_init($this_6.data.add(other_6.data));
    var $this_7 = h[6];
    var other_7 = paramG;
    h[6] = new ULong_init($this_7.data.add(other_7.data));
    var $this_8 = h[7];
    var other_8 = paramH;
    h[7] = new ULong_init($this_8.data.add(other_8.data));
    return h;
  };
  Sha512$Companion.prototype.createExpansionArray_za3lpa$ = function (originalSizeInBytes) {
    var tmp$;
    var originalMessageSizeInBits = originalSizeInBytes * 8 | 0;
    var expandedRemainderOf1024 = (originalMessageSizeInBits + 129 | 0) % 1024;
    if (expandedRemainderOf1024 === 0)
      tmp$ = 0;
    else
      tmp$ = (1024 - expandedRemainderOf1024 | 0) / 8 | 0;
    var zeroAddAmount = tmp$;
    var array = Array_0(zeroAddAmount + 1 | 0);
    var tmp$_0;
    tmp$_0 = array.length - 1 | 0;
    for (var i = 0; i <= tmp$_0; i++) {
      var init$result;
      if (i === 0) {
        init$result = new UByte_init(-128);
      }
       else {
        init$result = new UByte_init(0);
      }
      array[i] = init$result;
    }
    var expansionArray = array;
    return expansionArray;
  };
  Sha512$Companion.prototype.toPaddedByteArray_0 = function ($receiver) {
    var byteMask = new ULong_init(Kotlin.Long.fromInt(255));
    var array = Array_0(8);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    loop_label: for (var i = 0; i <= tmp$; i++) {
      var init$result;
      init$break: do {
        switch (i) {
          case 7:
            init$result = new UByte_init(toByte((new ULong_init($receiver.data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 6:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(8))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 5:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(16))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 4:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(24))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 3:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(32))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 2:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(40))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 1:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(48))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 0:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(56))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          default:init$result = new UByte_init(0);
            break init$break;
        }
      }
       while (false);
      array[i] = init$result;
    }
    return array;
  };
  Sha512$Companion.prototype.toPadded128BitByteArray_0 = function ($receiver) {
    var byteMask = new ULong_init(Kotlin.Long.fromInt(255));
    var array = Array_0(16);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    loop_label: for (var i = 0; i <= tmp$; i++) {
      var init$result;
      init$break: do {
        switch (i) {
          case 15:
            init$result = new UByte_init(toByte((new ULong_init($receiver.data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 14:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(8))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 13:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(16))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 12:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(24))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 11:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(32))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 10:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(40))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 9:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(48))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          case 8:
            init$result = new UByte_init(toByte((new ULong_init((new ULong_init($receiver.data.shiftRightUnsigned(54))).data.and(byteMask.data))).data.toInt()));
            break init$break;
          default:init$result = new UByte_init(0);
            break init$break;
        }
      }
       while (false);
      array[i] = init$result;
    }
    return array;
  };
  Sha512$Companion.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'Companion',
    interfaces: [StatelessHash]
  };
  var Sha512$Companion_instance = null;
  function Sha512$Companion_getInstance() {
    if (Sha512$Companion_instance === null) {
      new Sha512$Companion();
    }
    return Sha512$Companion_instance;
  }
  Sha512.prototype.update_61zpoe$ = function (data) {
    var $receiver = encodeToByteArray(data);
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(new UByte_init(item));
    }
    return this.update_ummv9a$(copyToArray(destination));
  };
  Sha512.prototype.update_ummv9a$ = function (data) {
    if (data.length === 0) {
      throw RuntimeException_init('Updating with empty array is not allowed. If you need empty hash, just call digest without updating');
    }
    if ((this.bufferCounter + data.length | 0) < 128)
      this.appendToBuffer_0(data, this.bufferCounter);
    else if ((this.bufferCounter + data.length | 0) >= 128) {
      var last = data.length % 128;
      var hasLast = last !== 0;
      var numberOfSlices = data.length / 128 | 0;
      var list = ArrayList_init(0);
      for (var index = 0; index < 0; index++) {
        list.add_11rb$(emptyList());
      }
      var result = list;
      for (var i = 0; i < numberOfSlices; i++) {
        result.add_11rb$(slice(data, until(Kotlin.imul(i, 128), Kotlin.imul(i + 1 | 0, 128))));
      }
      if (hasLast) {
        result.add_11rb$(slice(data, until(Kotlin.imul(numberOfSlices, 128), data.length)));
      }
      var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
      var tmp$;
      tmp$ = result.iterator();
      while (tmp$.hasNext()) {
        var item = tmp$.next();
        destination.add_11rb$(copyToArray(item));
      }
      var chunked = copyToArray(destination);
      var tmp$_0;
      for (tmp$_0 = 0; tmp$_0 !== chunked.length; ++tmp$_0) {
        var element = chunked[tmp$_0];
        if ((this.bufferCounter + element.length | 0) < 128) {
          this.appendToBuffer_0(element, this.bufferCounter);
        }
         else {
          arrayCopy(element, this.buffer, this.bufferCounter, 0, 128 - this.bufferCounter | 0);
          this.counter = this.counter + 128 | 0;
          this.consumeBlock_0(this.buffer);
          var array = Array_0(128);
          var tmp$_1;
          tmp$_1 = array.length - 1 | 0;
          for (var i_0 = 0; i_0 <= tmp$_1; i_0++) {
            var init$result;
            var tmp$_2;
            tmp$_2 = element.length - (128 - this.bufferCounter) | 0;
            if (0 <= i_0 && i_0 < tmp$_2) {
              init$result = element[i_0 + (128 - this.bufferCounter) | 0];
            }
             else {
              init$result = new UByte_init(0);
            }
            array[i_0] = init$result;
          }
          this.buffer = array;
          this.bufferCounter = element.length - (128 - this.bufferCounter) | 0;
        }
      }
    }
  };
  Sha512.prototype.consumeBlock_0 = function (block) {
    var w = Sha512$Companion_getInstance().expandChunk_0(block);
    var $receiver = Sha512$Companion_getInstance().mix_0(this.h, w);
    arrayCopy($receiver, this.h, 0, 0, $receiver.length);
  };
  Sha512.prototype.digest = function () {
    var length = this.counter + this.bufferCounter | 0;
    var expansionArray = Sha512$Companion_getInstance().createExpansionArray_za3lpa$(length);
    var tmp$ = copyOfRange(this.buffer, 0, this.bufferCounter).concat(expansionArray);
    var tmp$_0 = Sha512$Companion_getInstance();
    var $receiver = length * 8 | 0;
    var elements = tmp$_0.toPadded128BitByteArray_0(new ULong_init(Kotlin.Long.fromInt($receiver)));
    var finalBlock = tmp$.concat(elements);
    var last = finalBlock.length % 128;
    var hasLast = last !== 0;
    var numberOfSlices = finalBlock.length / 128 | 0;
    var list = ArrayList_init(0);
    for (var index = 0; index < 0; index++) {
      list.add_11rb$(emptyList());
    }
    var result = list;
    for (var i = 0; i < numberOfSlices; i++) {
      result.add_11rb$(slice(finalBlock, until(Kotlin.imul(i, 128), Kotlin.imul(i + 1 | 0, 128))));
    }
    if (hasLast) {
      result.add_11rb$(slice(finalBlock, until(Kotlin.imul(numberOfSlices, 128), finalBlock.length)));
    }
    var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
    var tmp$_1;
    tmp$_1 = result.iterator();
    while (tmp$_1.hasNext()) {
      var item = tmp$_1.next();
      destination.add_11rb$(copyToArray(item));
    }
    var $receiver_0 = copyToArray(destination);
    var tmp$_2;
    for (tmp$_2 = 0; tmp$_2 !== $receiver_0.length; ++tmp$_2) {
      var element = $receiver_0[tmp$_2];
      this.consumeBlock_0(element);
    }
    var $receiver_1 = Sha512$Companion_getInstance().toPaddedByteArray_0(this.h[0]);
    var elements_0 = Sha512$Companion_getInstance().toPaddedByteArray_0(this.h[1]);
    var $receiver_2 = $receiver_1.concat(elements_0);
    var elements_1 = Sha512$Companion_getInstance().toPaddedByteArray_0(this.h[2]);
    var $receiver_3 = $receiver_2.concat(elements_1);
    var elements_2 = Sha512$Companion_getInstance().toPaddedByteArray_0(this.h[3]);
    var $receiver_4 = $receiver_3.concat(elements_2);
    var elements_3 = Sha512$Companion_getInstance().toPaddedByteArray_0(this.h[4]);
    var $receiver_5 = $receiver_4.concat(elements_3);
    var elements_4 = Sha512$Companion_getInstance().toPaddedByteArray_0(this.h[5]);
    var $receiver_6 = $receiver_5.concat(elements_4);
    var elements_5 = Sha512$Companion_getInstance().toPaddedByteArray_0(this.h[6]);
    var $receiver_7 = $receiver_6.concat(elements_5);
    var elements_6 = Sha512$Companion_getInstance().toPaddedByteArray_0(this.h[7]);
    var digest = $receiver_7.concat(elements_6);
    return digest;
  };
  Sha512.prototype.digestString = function () {
    var $receiver = this.digest();
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(toString(item, 16));
    }
    return joinToString(destination, '');
  };
  Sha512.prototype.appendToBuffer_0 = function (array, start) {
    arrayCopy(array, this.buffer, start, 0, array.length);
    this.bufferCounter = this.bufferCounter + array.length | 0;
  };
  Sha512.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'Sha512',
    interfaces: [UpdatableHash]
  };
  function Aes(aesKey, input) {
    Aes$Companion_getInstance();
    this.aesKey = aesKey;
    this.input = input;
    var $receiver = until(0, 4);
    var destination = ArrayList_init(collectionSizeOrDefault($receiver, 10));
    var tmp$;
    tmp$ = $receiver.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      var tmp$_0 = destination.add_11rb$;
      var array = Array_0(4);
      var tmp$_1;
      tmp$_1 = array.length - 1 | 0;
      for (var i = 0; i <= tmp$_1; i++) {
        array[i] = this.input[(i * 4 | 0) + item | 0];
      }
      tmp$_0.call(destination, array);
    }
    this.state = copyToArray(destination);
    var tmp$_2, tmp$_3;
    tmp$_2 = this.aesKey;
    if (Kotlin.isType(tmp$_2, AesKey$Aes128Key))
      tmp$_3 = 10;
    else if (Kotlin.isType(tmp$_2, AesKey$Aes192Key))
      tmp$_3 = 12;
    else if (Kotlin.isType(tmp$_2, AesKey$Aes256Key))
      tmp$_3 = 14;
    else
      tmp$_3 = Kotlin.noWhenBranchMatched();
    this.numberOfRounds = tmp$_3;
    this.expandedKey = this.expandKey();
    this.round = 0;
    this.completed_igbl6$_0 = false;
  }
  function Aes$Companion() {
    Aes$Companion_instance = this;
    this.debug_0 = false;
    this.sBox_0 = new UByteArray(new Int8Array([(new UByte_init(99)).toByte(), (new UByte_init(124)).toByte(), (new UByte_init(119)).toByte(), (new UByte_init(123)).toByte(), (new UByte_init(-14)).toByte(), (new UByte_init(107)).toByte(), (new UByte_init(111)).toByte(), (new UByte_init(-59)).toByte(), (new UByte_init(48)).toByte(), (new UByte_init(1)).toByte(), (new UByte_init(103)).toByte(), (new UByte_init(43)).toByte(), (new UByte_init(-2)).toByte(), (new UByte_init(-41)).toByte(), (new UByte_init(-85)).toByte(), (new UByte_init(118)).toByte(), (new UByte_init(-54)).toByte(), (new UByte_init(-126)).toByte(), (new UByte_init(-55)).toByte(), (new UByte_init(125)).toByte(), (new UByte_init(-6)).toByte(), (new UByte_init(89)).toByte(), (new UByte_init(71)).toByte(), (new UByte_init(-16)).toByte(), (new UByte_init(-83)).toByte(), (new UByte_init(-44)).toByte(), (new UByte_init(-94)).toByte(), (new UByte_init(-81)).toByte(), (new UByte_init(-100)).toByte(), (new UByte_init(-92)).toByte(), (new UByte_init(114)).toByte(), (new UByte_init(-64)).toByte(), (new UByte_init(-73)).toByte(), (new UByte_init(-3)).toByte(), (new UByte_init(-109)).toByte(), (new UByte_init(38)).toByte(), (new UByte_init(54)).toByte(), (new UByte_init(63)).toByte(), (new UByte_init(-9)).toByte(), (new UByte_init(-52)).toByte(), (new UByte_init(52)).toByte(), (new UByte_init(-91)).toByte(), (new UByte_init(-27)).toByte(), (new UByte_init(-15)).toByte(), (new UByte_init(113)).toByte(), (new UByte_init(-40)).toByte(), (new UByte_init(49)).toByte(), (new UByte_init(21)).toByte(), (new UByte_init(4)).toByte(), (new UByte_init(-57)).toByte(), (new UByte_init(35)).toByte(), (new UByte_init(-61)).toByte(), (new UByte_init(24)).toByte(), (new UByte_init(-106)).toByte(), (new UByte_init(5)).toByte(), (new UByte_init(-102)).toByte(), (new UByte_init(7)).toByte(), (new UByte_init(18)).toByte(), (new UByte_init(-128)).toByte(), (new UByte_init(-30)).toByte(), (new UByte_init(-21)).toByte(), (new UByte_init(39)).toByte(), (new UByte_init(-78)).toByte(), (new UByte_init(117)).toByte(), (new UByte_init(9)).toByte(), (new UByte_init(-125)).toByte(), (new UByte_init(44)).toByte(), (new UByte_init(26)).toByte(), (new UByte_init(27)).toByte(), (new UByte_init(110)).toByte(), (new UByte_init(90)).toByte(), (new UByte_init(-96)).toByte(), (new UByte_init(82)).toByte(), (new UByte_init(59)).toByte(), (new UByte_init(-42)).toByte(), (new UByte_init(-77)).toByte(), (new UByte_init(41)).toByte(), (new UByte_init(-29)).toByte(), (new UByte_init(47)).toByte(), (new UByte_init(-124)).toByte(), (new UByte_init(83)).toByte(), (new UByte_init(-47)).toByte(), (new UByte_init(0)).toByte(), (new UByte_init(-19)).toByte(), (new UByte_init(32)).toByte(), (new UByte_init(-4)).toByte(), (new UByte_init(-79)).toByte(), (new UByte_init(91)).toByte(), (new UByte_init(106)).toByte(), (new UByte_init(-53)).toByte(), (new UByte_init(-66)).toByte(), (new UByte_init(57)).toByte(), (new UByte_init(74)).toByte(), (new UByte_init(76)).toByte(), (new UByte_init(88)).toByte(), (new UByte_init(-49)).toByte(), (new UByte_init(-48)).toByte(), (new UByte_init(-17)).toByte(), (new UByte_init(-86)).toByte(), (new UByte_init(-5)).toByte(), (new UByte_init(67)).toByte(), (new UByte_init(77)).toByte(), (new UByte_init(51)).toByte(), (new UByte_init(-123)).toByte(), (new UByte_init(69)).toByte(), (new UByte_init(-7)).toByte(), (new UByte_init(2)).toByte(), (new UByte_init(127)).toByte(), (new UByte_init(80)).toByte(), (new UByte_init(60)).toByte(), (new UByte_init(-97)).toByte(), (new UByte_init(-88)).toByte(), (new UByte_init(81)).toByte(), (new UByte_init(-93)).toByte(), (new UByte_init(64)).toByte(), (new UByte_init(-113)).toByte(), (new UByte_init(-110)).toByte(), (new UByte_init(-99)).toByte(), (new UByte_init(56)).toByte(), (new UByte_init(-11)).toByte(), (new UByte_init(-68)).toByte(), (new UByte_init(-74)).toByte(), (new UByte_init(-38)).toByte(), (new UByte_init(33)).toByte(), (new UByte_init(16)).toByte(), (new UByte_init(-1)).toByte(), (new UByte_init(-13)).toByte(), (new UByte_init(-46)).toByte(), (new UByte_init(-51)).toByte(), (new UByte_init(12)).toByte(), (new UByte_init(19)).toByte(), (new UByte_init(-20)).toByte(), (new UByte_init(95)).toByte(), (new UByte_init(-105)).toByte(), (new UByte_init(68)).toByte(), (new UByte_init(23)).toByte(), (new UByte_init(-60)).toByte(), (new UByte_init(-89)).toByte(), (new UByte_init(126)).toByte(), (new UByte_init(61)).toByte(), (new UByte_init(100)).toByte(), (new UByte_init(93)).toByte(), (new UByte_init(25)).toByte(), (new UByte_init(115)).toByte(), (new UByte_init(96)).toByte(), (new UByte_init(-127)).toByte(), (new UByte_init(79)).toByte(), (new UByte_init(-36)).toByte(), (new UByte_init(34)).toByte(), (new UByte_init(42)).toByte(), (new UByte_init(-112)).toByte(), (new UByte_init(-120)).toByte(), (new UByte_init(70)).toByte(), (new UByte_init(-18)).toByte(), (new UByte_init(-72)).toByte(), (new UByte_init(20)).toByte(), (new UByte_init(-34)).toByte(), (new UByte_init(94)).toByte(), (new UByte_init(11)).toByte(), (new UByte_init(-37)).toByte(), (new UByte_init(-32)).toByte(), (new UByte_init(50)).toByte(), (new UByte_init(58)).toByte(), (new UByte_init(10)).toByte(), (new UByte_init(73)).toByte(), (new UByte_init(6)).toByte(), (new UByte_init(36)).toByte(), (new UByte_init(92)).toByte(), (new UByte_init(-62)).toByte(), (new UByte_init(-45)).toByte(), (new UByte_init(-84)).toByte(), (new UByte_init(98)).toByte(), (new UByte_init(-111)).toByte(), (new UByte_init(-107)).toByte(), (new UByte_init(-28)).toByte(), (new UByte_init(121)).toByte(), (new UByte_init(-25)).toByte(), (new UByte_init(-56)).toByte(), (new UByte_init(55)).toByte(), (new UByte_init(109)).toByte(), (new UByte_init(-115)).toByte(), (new UByte_init(-43)).toByte(), (new UByte_init(78)).toByte(), (new UByte_init(-87)).toByte(), (new UByte_init(108)).toByte(), (new UByte_init(86)).toByte(), (new UByte_init(-12)).toByte(), (new UByte_init(-22)).toByte(), (new UByte_init(101)).toByte(), (new UByte_init(122)).toByte(), (new UByte_init(-82)).toByte(), (new UByte_init(8)).toByte(), (new UByte_init(-70)).toByte(), (new UByte_init(120)).toByte(), (new UByte_init(37)).toByte(), (new UByte_init(46)).toByte(), (new UByte_init(28)).toByte(), (new UByte_init(-90)).toByte(), (new UByte_init(-76)).toByte(), (new UByte_init(-58)).toByte(), (new UByte_init(-24)).toByte(), (new UByte_init(-35)).toByte(), (new UByte_init(116)).toByte(), (new UByte_init(31)).toByte(), (new UByte_init(75)).toByte(), (new UByte_init(-67)).toByte(), (new UByte_init(-117)).toByte(), (new UByte_init(-118)).toByte(), (new UByte_init(112)).toByte(), (new UByte_init(62)).toByte(), (new UByte_init(-75)).toByte(), (new UByte_init(102)).toByte(), (new UByte_init(72)).toByte(), (new UByte_init(3)).toByte(), (new UByte_init(-10)).toByte(), (new UByte_init(14)).toByte(), (new UByte_init(97)).toByte(), (new UByte_init(53)).toByte(), (new UByte_init(87)).toByte(), (new UByte_init(-71)).toByte(), (new UByte_init(-122)).toByte(), (new UByte_init(-63)).toByte(), (new UByte_init(29)).toByte(), (new UByte_init(-98)).toByte(), (new UByte_init(-31)).toByte(), (new UByte_init(-8)).toByte(), (new UByte_init(-104)).toByte(), (new UByte_init(17)).toByte(), (new UByte_init(105)).toByte(), (new UByte_init(-39)).toByte(), (new UByte_init(-114)).toByte(), (new UByte_init(-108)).toByte(), (new UByte_init(-101)).toByte(), (new UByte_init(30)).toByte(), (new UByte_init(-121)).toByte(), (new UByte_init(-23)).toByte(), (new UByte_init(-50)).toByte(), (new UByte_init(85)).toByte(), (new UByte_init(40)).toByte(), (new UByte_init(-33)).toByte(), (new UByte_init(-116)).toByte(), (new UByte_init(-95)).toByte(), (new UByte_init(-119)).toByte(), (new UByte_init(13)).toByte(), (new UByte_init(-65)).toByte(), (new UByte_init(-26)).toByte(), (new UByte_init(66)).toByte(), (new UByte_init(104)).toByte(), (new UByte_init(65)).toByte(), (new UByte_init(-103)).toByte(), (new UByte_init(45)).toByte(), (new UByte_init(15)).toByte(), (new UByte_init(-80)).toByte(), (new UByte_init(84)).toByte(), (new UByte_init(-69)).toByte(), (new UByte_init(22)).toByte()]));
    this.inverseSBox_0 = new UByteArray(new Int8Array([(new UByte_init(82)).toByte(), (new UByte_init(9)).toByte(), (new UByte_init(106)).toByte(), (new UByte_init(-43)).toByte(), (new UByte_init(48)).toByte(), (new UByte_init(54)).toByte(), (new UByte_init(-91)).toByte(), (new UByte_init(56)).toByte(), (new UByte_init(-65)).toByte(), (new UByte_init(64)).toByte(), (new UByte_init(-93)).toByte(), (new UByte_init(-98)).toByte(), (new UByte_init(-127)).toByte(), (new UByte_init(-13)).toByte(), (new UByte_init(-41)).toByte(), (new UByte_init(-5)).toByte(), (new UByte_init(124)).toByte(), (new UByte_init(-29)).toByte(), (new UByte_init(57)).toByte(), (new UByte_init(-126)).toByte(), (new UByte_init(-101)).toByte(), (new UByte_init(47)).toByte(), (new UByte_init(-1)).toByte(), (new UByte_init(-121)).toByte(), (new UByte_init(52)).toByte(), (new UByte_init(-114)).toByte(), (new UByte_init(67)).toByte(), (new UByte_init(68)).toByte(), (new UByte_init(-60)).toByte(), (new UByte_init(-34)).toByte(), (new UByte_init(-23)).toByte(), (new UByte_init(-53)).toByte(), (new UByte_init(84)).toByte(), (new UByte_init(123)).toByte(), (new UByte_init(-108)).toByte(), (new UByte_init(50)).toByte(), (new UByte_init(-90)).toByte(), (new UByte_init(-62)).toByte(), (new UByte_init(35)).toByte(), (new UByte_init(61)).toByte(), (new UByte_init(-18)).toByte(), (new UByte_init(76)).toByte(), (new UByte_init(-107)).toByte(), (new UByte_init(11)).toByte(), (new UByte_init(66)).toByte(), (new UByte_init(-6)).toByte(), (new UByte_init(-61)).toByte(), (new UByte_init(78)).toByte(), (new UByte_init(8)).toByte(), (new UByte_init(46)).toByte(), (new UByte_init(-95)).toByte(), (new UByte_init(102)).toByte(), (new UByte_init(40)).toByte(), (new UByte_init(-39)).toByte(), (new UByte_init(36)).toByte(), (new UByte_init(-78)).toByte(), (new UByte_init(118)).toByte(), (new UByte_init(91)).toByte(), (new UByte_init(-94)).toByte(), (new UByte_init(73)).toByte(), (new UByte_init(109)).toByte(), (new UByte_init(-117)).toByte(), (new UByte_init(-47)).toByte(), (new UByte_init(37)).toByte(), (new UByte_init(114)).toByte(), (new UByte_init(-8)).toByte(), (new UByte_init(-10)).toByte(), (new UByte_init(100)).toByte(), (new UByte_init(-122)).toByte(), (new UByte_init(104)).toByte(), (new UByte_init(-104)).toByte(), (new UByte_init(22)).toByte(), (new UByte_init(-44)).toByte(), (new UByte_init(-92)).toByte(), (new UByte_init(92)).toByte(), (new UByte_init(-52)).toByte(), (new UByte_init(93)).toByte(), (new UByte_init(101)).toByte(), (new UByte_init(-74)).toByte(), (new UByte_init(-110)).toByte(), (new UByte_init(108)).toByte(), (new UByte_init(112)).toByte(), (new UByte_init(72)).toByte(), (new UByte_init(80)).toByte(), (new UByte_init(-3)).toByte(), (new UByte_init(-19)).toByte(), (new UByte_init(-71)).toByte(), (new UByte_init(-38)).toByte(), (new UByte_init(94)).toByte(), (new UByte_init(21)).toByte(), (new UByte_init(70)).toByte(), (new UByte_init(87)).toByte(), (new UByte_init(-89)).toByte(), (new UByte_init(-115)).toByte(), (new UByte_init(-99)).toByte(), (new UByte_init(-124)).toByte(), (new UByte_init(-112)).toByte(), (new UByte_init(-40)).toByte(), (new UByte_init(-85)).toByte(), (new UByte_init(0)).toByte(), (new UByte_init(-116)).toByte(), (new UByte_init(-68)).toByte(), (new UByte_init(-45)).toByte(), (new UByte_init(10)).toByte(), (new UByte_init(-9)).toByte(), (new UByte_init(-28)).toByte(), (new UByte_init(88)).toByte(), (new UByte_init(5)).toByte(), (new UByte_init(-72)).toByte(), (new UByte_init(-77)).toByte(), (new UByte_init(69)).toByte(), (new UByte_init(6)).toByte(), (new UByte_init(-48)).toByte(), (new UByte_init(44)).toByte(), (new UByte_init(30)).toByte(), (new UByte_init(-113)).toByte(), (new UByte_init(-54)).toByte(), (new UByte_init(63)).toByte(), (new UByte_init(15)).toByte(), (new UByte_init(2)).toByte(), (new UByte_init(-63)).toByte(), (new UByte_init(-81)).toByte(), (new UByte_init(-67)).toByte(), (new UByte_init(3)).toByte(), (new UByte_init(1)).toByte(), (new UByte_init(19)).toByte(), (new UByte_init(-118)).toByte(), (new UByte_init(107)).toByte(), (new UByte_init(58)).toByte(), (new UByte_init(-111)).toByte(), (new UByte_init(17)).toByte(), (new UByte_init(65)).toByte(), (new UByte_init(79)).toByte(), (new UByte_init(103)).toByte(), (new UByte_init(-36)).toByte(), (new UByte_init(-22)).toByte(), (new UByte_init(-105)).toByte(), (new UByte_init(-14)).toByte(), (new UByte_init(-49)).toByte(), (new UByte_init(-50)).toByte(), (new UByte_init(-16)).toByte(), (new UByte_init(-76)).toByte(), (new UByte_init(-26)).toByte(), (new UByte_init(115)).toByte(), (new UByte_init(-106)).toByte(), (new UByte_init(-84)).toByte(), (new UByte_init(116)).toByte(), (new UByte_init(34)).toByte(), (new UByte_init(-25)).toByte(), (new UByte_init(-83)).toByte(), (new UByte_init(53)).toByte(), (new UByte_init(-123)).toByte(), (new UByte_init(-30)).toByte(), (new UByte_init(-7)).toByte(), (new UByte_init(55)).toByte(), (new UByte_init(-24)).toByte(), (new UByte_init(28)).toByte(), (new UByte_init(117)).toByte(), (new UByte_init(-33)).toByte(), (new UByte_init(110)).toByte(), (new UByte_init(71)).toByte(), (new UByte_init(-15)).toByte(), (new UByte_init(26)).toByte(), (new UByte_init(113)).toByte(), (new UByte_init(29)).toByte(), (new UByte_init(41)).toByte(), (new UByte_init(-59)).toByte(), (new UByte_init(-119)).toByte(), (new UByte_init(111)).toByte(), (new UByte_init(-73)).toByte(), (new UByte_init(98)).toByte(), (new UByte_init(14)).toByte(), (new UByte_init(-86)).toByte(), (new UByte_init(24)).toByte(), (new UByte_init(-66)).toByte(), (new UByte_init(27)).toByte(), (new UByte_init(-4)).toByte(), (new UByte_init(86)).toByte(), (new UByte_init(62)).toByte(), (new UByte_init(75)).toByte(), (new UByte_init(-58)).toByte(), (new UByte_init(-46)).toByte(), (new UByte_init(121)).toByte(), (new UByte_init(32)).toByte(), (new UByte_init(-102)).toByte(), (new UByte_init(-37)).toByte(), (new UByte_init(-64)).toByte(), (new UByte_init(-2)).toByte(), (new UByte_init(120)).toByte(), (new UByte_init(-51)).toByte(), (new UByte_init(90)).toByte(), (new UByte_init(-12)).toByte(), (new UByte_init(31)).toByte(), (new UByte_init(-35)).toByte(), (new UByte_init(-88)).toByte(), (new UByte_init(51)).toByte(), (new UByte_init(-120)).toByte(), (new UByte_init(7)).toByte(), (new UByte_init(-57)).toByte(), (new UByte_init(49)).toByte(), (new UByte_init(-79)).toByte(), (new UByte_init(18)).toByte(), (new UByte_init(16)).toByte(), (new UByte_init(89)).toByte(), (new UByte_init(39)).toByte(), (new UByte_init(-128)).toByte(), (new UByte_init(-20)).toByte(), (new UByte_init(95)).toByte(), (new UByte_init(96)).toByte(), (new UByte_init(81)).toByte(), (new UByte_init(127)).toByte(), (new UByte_init(-87)).toByte(), (new UByte_init(25)).toByte(), (new UByte_init(-75)).toByte(), (new UByte_init(74)).toByte(), (new UByte_init(13)).toByte(), (new UByte_init(45)).toByte(), (new UByte_init(-27)).toByte(), (new UByte_init(122)).toByte(), (new UByte_init(-97)).toByte(), (new UByte_init(-109)).toByte(), (new UByte_init(-55)).toByte(), (new UByte_init(-100)).toByte(), (new UByte_init(-17)).toByte(), (new UByte_init(-96)).toByte(), (new UByte_init(-32)).toByte(), (new UByte_init(59)).toByte(), (new UByte_init(77)).toByte(), (new UByte_init(-82)).toByte(), (new UByte_init(42)).toByte(), (new UByte_init(-11)).toByte(), (new UByte_init(-80)).toByte(), (new UByte_init(-56)).toByte(), (new UByte_init(-21)).toByte(), (new UByte_init(-69)).toByte(), (new UByte_init(60)).toByte(), (new UByte_init(-125)).toByte(), (new UByte_init(83)).toByte(), (new UByte_init(-103)).toByte(), (new UByte_init(97)).toByte(), (new UByte_init(23)).toByte(), (new UByte_init(43)).toByte(), (new UByte_init(4)).toByte(), (new UByte_init(126)).toByte(), (new UByte_init(-70)).toByte(), (new UByte_init(119)).toByte(), (new UByte_init(-42)).toByte(), (new UByte_init(38)).toByte(), (new UByte_init(-31)).toByte(), (new UByte_init(105)).toByte(), (new UByte_init(20)).toByte(), (new UByte_init(99)).toByte(), (new UByte_init(85)).toByte(), (new UByte_init(33)).toByte(), (new UByte_init(12)).toByte(), (new UByte_init(125)).toByte()]));
    this.rcon = new UByteArray(new Int8Array([(new UByte_init(-115)).toByte(), (new UByte_init(1)).toByte(), (new UByte_init(2)).toByte(), (new UByte_init(4)).toByte(), (new UByte_init(8)).toByte(), (new UByte_init(16)).toByte(), (new UByte_init(32)).toByte(), (new UByte_init(64)).toByte(), (new UByte_init(-128)).toByte(), (new UByte_init(27)).toByte(), (new UByte_init(54)).toByte()]));
  }
  Aes$Companion.prototype.encrypt_dx3icu$ = function (aesKey, input) {
    return (new Aes(aesKey, input)).encrypt();
  };
  Aes$Companion.prototype.decrypt_dx3icu$ = function (aesKey, input) {
    return (new Aes(aesKey, input)).decrypt();
  };
  Aes$Companion.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'Companion',
    interfaces: []
  };
  var Aes$Companion_instance = null;
  function Aes$Companion_getInstance() {
    if (Aes$Companion_instance === null) {
      new Aes$Companion();
    }
    return Aes$Companion_instance;
  }
  Object.defineProperty(Aes.prototype, 'completed', {
    get: function () {
      return this.completed_igbl6$_0;
    },
    set: function (completed) {
      this.completed_igbl6$_0 = completed;
    }
  });
  Aes.prototype.subBytes = function () {
    var $receiver = this.state;
    var tmp$, tmp$_0;
    var index = 0;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      var indexRow = (tmp$_0 = index, index = tmp$_0 + 1 | 0, tmp$_0);
      var tmp$_1, tmp$_0_0;
      var index_0 = 0;
      for (tmp$_1 = 0; tmp$_1 !== item.length; ++tmp$_1) {
        var item_0 = item[tmp$_1];
        var indexColumn = (tmp$_0_0 = index_0, index_0 = tmp$_0_0 + 1 | 0, tmp$_0_0);
        this.state[indexRow][indexColumn] = this.getSBoxValue_mpmjao$(item_0);
      }
    }
  };
  Aes.prototype.getSBoxValue_mpmjao$ = function (element) {
    var other = new UInt(16);
    var firstDigit = uintDivide(new UInt(element.data & 255), other).data;
    var other_0 = new UInt(16);
    var secondDigit = uintRemainder(new UInt(element.data & 255), other_0).data;
    return Aes$Companion_getInstance().sBox_0.get_za3lpa$((firstDigit * 16 | 0) + secondDigit | 0);
  };
  Aes.prototype.inverseSubBytes = function () {
    var $receiver = this.state;
    var tmp$, tmp$_0;
    var index = 0;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      var indexRow = (tmp$_0 = index, index = tmp$_0 + 1 | 0, tmp$_0);
      var tmp$_1, tmp$_0_0;
      var index_0 = 0;
      for (tmp$_1 = 0; tmp$_1 !== item.length; ++tmp$_1) {
        var item_0 = item[tmp$_1];
        var indexColumn = (tmp$_0_0 = index_0, index_0 = tmp$_0_0 + 1 | 0, tmp$_0_0);
        this.state[indexRow][indexColumn] = this.getInverseSBoxValue_mpmjao$(item_0);
      }
    }
  };
  Aes.prototype.getInverseSBoxValue_mpmjao$ = function (element) {
    var other = new UInt(16);
    var firstDigit = uintDivide(new UInt(element.data & 255), other).data;
    var other_0 = new UInt(16);
    var secondDigit = uintRemainder(new UInt(element.data & 255), other_0).data;
    return Aes$Companion_getInstance().inverseSBox_0.get_za3lpa$((firstDigit * 16 | 0) + secondDigit | 0);
  };
  Aes.prototype.shiftRows = function () {
    this.state[0] = [this.state[0][0], this.state[0][1], this.state[0][2], this.state[0][3]];
    this.state[1] = [this.state[1][1], this.state[1][2], this.state[1][3], this.state[1][0]];
    this.state[2] = [this.state[2][2], this.state[2][3], this.state[2][0], this.state[2][1]];
    this.state[3] = [this.state[3][3], this.state[3][0], this.state[3][1], this.state[3][2]];
  };
  Aes.prototype.inversShiftRows = function () {
    this.state[0] = [this.state[0][0], this.state[0][1], this.state[0][2], this.state[0][3]];
    this.state[1] = [this.state[1][3], this.state[1][0], this.state[1][1], this.state[1][2]];
    this.state[2] = [this.state[2][2], this.state[2][3], this.state[2][0], this.state[2][1]];
    this.state[3] = [this.state[3][1], this.state[3][2], this.state[3][3], this.state[3][0]];
  };
  Aes.prototype.mixColumns = function () {
    var $receiver = until(0, 4);
    var destination = ArrayList_init(collectionSizeOrDefault($receiver, 10));
    var tmp$;
    tmp$ = $receiver.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      var tmp$_0 = destination.add_11rb$;
      var array = Array_0(4);
      var tmp$_1;
      tmp$_1 = array.length - 1 | 0;
      for (var i = 0; i <= tmp$_1; i++) {
        array[i] = new UByte_init(0);
      }
      tmp$_0.call(destination, array);
    }
    var stateMixed = copyToArray(destination);
    for (var c = 0; c <= 3; c++) {
      var tmp$_2 = stateMixed[0];
      var $this = this.gfm_lc54$(new UInt(2), this.state[0][c]);
      var other = this.gfm_lc54$(new UInt(3), this.state[1][c]);
      var $this_0 = new UByte_init(toByte($this.data ^ other.data));
      var other_0 = this.state[2][c];
      var $this_1 = new UByte_init(toByte($this_0.data ^ other_0.data));
      var other_1 = this.state[3][c];
      tmp$_2[c] = new UByte_init(toByte($this_1.data ^ other_1.data));
      var tmp$_3 = stateMixed[1];
      var $this_2 = this.state[0][c];
      var other_2 = this.gfm_lc54$(new UInt(2), this.state[1][c]);
      var $this_3 = new UByte_init(toByte($this_2.data ^ other_2.data));
      var other_3 = this.gfm_lc54$(new UInt(3), this.state[2][c]);
      var $this_4 = new UByte_init(toByte($this_3.data ^ other_3.data));
      var other_4 = this.state[3][c];
      tmp$_3[c] = new UByte_init(toByte($this_4.data ^ other_4.data));
      var tmp$_4 = stateMixed[2];
      var $this_5 = this.state[0][c];
      var other_5 = this.state[1][c];
      var $this_6 = new UByte_init(toByte($this_5.data ^ other_5.data));
      var other_6 = this.gfm_lc54$(new UInt(2), this.state[2][c]);
      var $this_7 = new UByte_init(toByte($this_6.data ^ other_6.data));
      var other_7 = this.gfm_lc54$(new UInt(3), this.state[3][c]);
      tmp$_4[c] = new UByte_init(toByte($this_7.data ^ other_7.data));
      var tmp$_5 = stateMixed[3];
      var $this_8 = this.gfm_lc54$(new UInt(3), this.state[0][c]);
      var other_8 = this.state[1][c];
      var $this_9 = new UByte_init(toByte($this_8.data ^ other_8.data));
      var other_9 = this.state[2][c];
      var $this_10 = new UByte_init(toByte($this_9.data ^ other_9.data));
      var other_10 = this.gfm_lc54$(new UInt(2), this.state[3][c]);
      tmp$_5[c] = new UByte_init(toByte($this_10.data ^ other_10.data));
    }
    arrayCopy(stateMixed, this.state, 0, 0, stateMixed.length);
  };
  Aes.prototype.inverseMixColumns = function () {
    var $receiver = until(0, 4);
    var destination = ArrayList_init(collectionSizeOrDefault($receiver, 10));
    var tmp$;
    tmp$ = $receiver.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      var tmp$_0 = destination.add_11rb$;
      var array = Array_0(4);
      var tmp$_1;
      tmp$_1 = array.length - 1 | 0;
      for (var i = 0; i <= tmp$_1; i++) {
        array[i] = new UByte_init(0);
      }
      tmp$_0.call(destination, array);
    }
    var stateMixed = copyToArray(destination);
    for (var c = 0; c <= 3; c++) {
      var tmp$_2 = stateMixed[0];
      var $this = this.gfm_lc54$(new UInt(14), this.state[0][c]);
      var other = this.gfm_lc54$(new UInt(11), this.state[1][c]);
      var $this_0 = new UByte_init(toByte($this.data ^ other.data));
      var other_0 = this.gfm_lc54$(new UInt(13), this.state[2][c]);
      var $this_1 = new UByte_init(toByte($this_0.data ^ other_0.data));
      var other_1 = this.gfm_lc54$(new UInt(9), this.state[3][c]);
      tmp$_2[c] = new UByte_init(toByte($this_1.data ^ other_1.data));
      var tmp$_3 = stateMixed[1];
      var $this_2 = this.gfm_lc54$(new UInt(9), this.state[0][c]);
      var other_2 = this.gfm_lc54$(new UInt(14), this.state[1][c]);
      var $this_3 = new UByte_init(toByte($this_2.data ^ other_2.data));
      var other_3 = this.gfm_lc54$(new UInt(11), this.state[2][c]);
      var $this_4 = new UByte_init(toByte($this_3.data ^ other_3.data));
      var other_4 = this.gfm_lc54$(new UInt(13), this.state[3][c]);
      tmp$_3[c] = new UByte_init(toByte($this_4.data ^ other_4.data));
      var tmp$_4 = stateMixed[2];
      var $this_5 = this.gfm_lc54$(new UInt(13), this.state[0][c]);
      var other_5 = this.gfm_lc54$(new UInt(9), this.state[1][c]);
      var $this_6 = new UByte_init(toByte($this_5.data ^ other_5.data));
      var other_6 = this.gfm_lc54$(new UInt(14), this.state[2][c]);
      var $this_7 = new UByte_init(toByte($this_6.data ^ other_6.data));
      var other_7 = this.gfm_lc54$(new UInt(11), this.state[3][c]);
      tmp$_4[c] = new UByte_init(toByte($this_7.data ^ other_7.data));
      var tmp$_5 = stateMixed[3];
      var $this_8 = this.gfm_lc54$(new UInt(11), this.state[0][c]);
      var other_8 = this.gfm_lc54$(new UInt(13), this.state[1][c]);
      var $this_9 = new UByte_init(toByte($this_8.data ^ other_8.data));
      var other_9 = this.gfm_lc54$(new UInt(9), this.state[2][c]);
      var $this_10 = new UByte_init(toByte($this_9.data ^ other_9.data));
      var other_10 = this.gfm_lc54$(new UInt(14), this.state[3][c]);
      tmp$_5[c] = new UByte_init(toByte($this_10.data ^ other_10.data));
    }
    arrayCopy(stateMixed, this.state, 0, 0, stateMixed.length);
  };
  Aes.prototype.galoisFieldAdd_jl2jf8$ = function (first, second) {
    return new UByte_init(toByte(first.data ^ second.data));
  };
  Aes.prototype.galoisFieldMultiply_jl2jf8$ = function (first, second) {
    var tmp$;
    var result = new UInt(0);
    var firstInt = new UInt(first.data & 255);
    var secondInt = new UInt(second.data & 255);
    var carry = new UInt(0);
    for (var i = 0; i <= 7; i++) {
      var $this = secondInt;
      var other = new UInt(1);
      if ((tmp$ = new UInt($this.data & other.data)) != null ? tmp$.equals(new UInt(1)) : null) {
        var $this_0 = result;
        var other_0 = firstInt;
        result = new UInt($this_0.data ^ other_0.data);
      }
      var $this_1 = firstInt;
      var other_1 = new UInt(128);
      carry = new UInt($this_1.data & other_1.data);
      firstInt = new UInt(firstInt.data << 1);
      if (carry != null ? carry.equals(new UInt(128)) : null) {
        var $this_2 = firstInt;
        var other_2 = new UInt(27);
        firstInt = new UInt($this_2.data ^ other_2.data);
      }
      secondInt = new UInt(secondInt.data >>> 1);
      var $this_3 = firstInt;
      var other_3 = new UInt(255);
      firstInt = new UInt($this_3.data & other_3.data);
    }
    return new UByte_init(toByte(result.data));
  };
  Aes.prototype.addRoundKey = function () {
    for (var i = 0; i < 4; i++) {
      var tmp$ = this.state[0];
      var $this = this.state[0][i];
      var other = this.expandedKey[(this.round * 4 | 0) + i | 0][0];
      tmp$[i] = new UByte_init(toByte($this.data ^ other.data));
      var tmp$_0 = this.state[1];
      var $this_0 = this.state[1][i];
      var other_0 = this.expandedKey[(this.round * 4 | 0) + i | 0][1];
      tmp$_0[i] = new UByte_init(toByte($this_0.data ^ other_0.data));
      var tmp$_1 = this.state[2];
      var $this_1 = this.state[2][i];
      var other_1 = this.expandedKey[(this.round * 4 | 0) + i | 0][2];
      tmp$_1[i] = new UByte_init(toByte($this_1.data ^ other_1.data));
      var tmp$_2 = this.state[3];
      var $this_2 = this.state[3][i];
      var other_2 = this.expandedKey[(this.round * 4 | 0) + i | 0][3];
      tmp$_2[i] = new UByte_init(toByte($this_2.data ^ other_2.data));
    }
    this.round = this.round + 1 | 0;
  };
  Aes.prototype.inverseAddRoundKey = function () {
    for (var i = 0; i < 4; i++) {
      var tmp$ = this.state[0];
      var $this = this.state[0][i];
      var other = this.expandedKey[(this.round * 4 | 0) + i | 0][0];
      tmp$[i] = new UByte_init(toByte($this.data ^ other.data));
      var tmp$_0 = this.state[1];
      var $this_0 = this.state[1][i];
      var other_0 = this.expandedKey[(this.round * 4 | 0) + i | 0][1];
      tmp$_0[i] = new UByte_init(toByte($this_0.data ^ other_0.data));
      var tmp$_1 = this.state[2];
      var $this_1 = this.state[2][i];
      var other_1 = this.expandedKey[(this.round * 4 | 0) + i | 0][2];
      tmp$_1[i] = new UByte_init(toByte($this_1.data ^ other_1.data));
      var tmp$_2 = this.state[3];
      var $this_2 = this.state[3][i];
      var other_2 = this.expandedKey[(this.round * 4 | 0) + i | 0][3];
      tmp$_2[i] = new UByte_init(toByte($this_2.data ^ other_2.data));
    }
    this.round = this.round - 1 | 0;
  };
  Aes.prototype.gfm_lc54$ = function ($receiver, second) {
    return this.galoisFieldMultiply_jl2jf8$(new UByte_init(toByte($receiver.data)), second);
  };
  Aes.prototype.expandKey = function () {
    var tmp$, tmp$_0, tmp$_1;
    var $receiver = until(0, 4 * (this.numberOfRounds + 1 | 0) | 0);
    var destination = ArrayList_init(collectionSizeOrDefault($receiver, 10));
    var tmp$_2;
    tmp$_2 = $receiver.iterator();
    while (tmp$_2.hasNext()) {
      var item = tmp$_2.next();
      var tmp$_3 = destination.add_11rb$;
      var array = Array_0(4);
      var tmp$_4;
      tmp$_4 = array.length - 1 | 0;
      for (var i = 0; i <= tmp$_4; i++) {
        array[i] = new UByte_init(0);
      }
      tmp$_3.call(destination, array);
    }
    var expandedKey = copyToArray(destination);
    tmp$ = this.aesKey.numberOf32BitWords;
    for (var i_0 = 0; i_0 < tmp$; i_0++) {
      expandedKey[i_0][0] = this.aesKey.keyArray[(i_0 * 4 | 0) + 0 | 0];
      expandedKey[i_0][1] = this.aesKey.keyArray[(i_0 * 4 | 0) + 1 | 0];
      expandedKey[i_0][2] = this.aesKey.keyArray[(i_0 * 4 | 0) + 2 | 0];
      expandedKey[i_0][3] = this.aesKey.keyArray[(i_0 * 4 | 0) + 3 | 0];
    }
    tmp$_0 = this.aesKey.numberOf32BitWords;
    tmp$_1 = 4 * (this.numberOfRounds + 1 | 0) | 0;
    for (var i_1 = tmp$_0; i_1 < tmp$_1; i_1++) {
      var temp = expandedKey[i_1 - 1 | 0].slice();
      if (i_1 % this.aesKey.numberOf32BitWords === 0) {
        var tempTemp = temp[0];
        temp[0] = temp[1];
        temp[1] = temp[2];
        temp[2] = temp[3];
        temp[3] = tempTemp;
        temp[0] = this.getSBoxValue_mpmjao$(temp[0]);
        temp[1] = this.getSBoxValue_mpmjao$(temp[1]);
        temp[2] = this.getSBoxValue_mpmjao$(temp[2]);
        temp[3] = this.getSBoxValue_mpmjao$(temp[3]);
        var $this = temp[0];
        var other = Aes$Companion_getInstance().rcon.get_za3lpa$(i_1 / this.aesKey.numberOf32BitWords | 0);
        temp[0] = new UByte_init(toByte($this.data ^ other.data));
      }
       else if (Kotlin.isType(this.aesKey, AesKey$Aes256Key) && i_1 % this.aesKey.numberOf32BitWords === 4) {
        temp[0] = this.getSBoxValue_mpmjao$(temp[0]);
        temp[1] = this.getSBoxValue_mpmjao$(temp[1]);
        temp[2] = this.getSBoxValue_mpmjao$(temp[2]);
        temp[3] = this.getSBoxValue_mpmjao$(temp[3]);
      }
      var $receiver_0 = expandedKey[i_1 - this.aesKey.numberOf32BitWords | 0];
      var destination_0 = ArrayList_init($receiver_0.length);
      var tmp$_5, tmp$_0_0;
      var index = 0;
      for (tmp$_5 = 0; tmp$_5 !== $receiver_0.length; ++tmp$_5) {
        var item_0 = $receiver_0[tmp$_5];
        var tmp$_6 = destination_0.add_11rb$;
        var other_0 = temp[tmp$_0_0 = index, index = tmp$_0_0 + 1 | 0, tmp$_0_0];
        tmp$_6.call(destination_0, new UByte_init(toByte(item_0.data ^ other_0.data)));
      }
      expandedKey[i_1] = copyToArray(destination_0);
      this.clearArray_0(temp);
    }
    return expandedKey;
  };
  Aes.prototype.encrypt = function () {
    var tmp$;
    if (this.completed) {
      throw RuntimeException_init('Encrypt can only be called once per Aes instance, since the state is cleared at the ' + 'end of the operation');
    }
    this.printState_0();
    this.addRoundKey();
    this.printState_0();
    tmp$ = this.numberOfRounds - 1 | 0;
    for (var i = 0; i < tmp$; i++) {
      this.subBytes();
      this.printState_0();
      this.shiftRows();
      this.printState_0();
      this.mixColumns();
      this.printState_0();
      this.addRoundKey();
      this.printState_0();
    }
    this.subBytes();
    this.printState_0();
    this.shiftRows();
    this.printState_0();
    this.addRoundKey();
    this.printState_0();
    var $receiver = until(0, 4);
    var destination = ArrayList_init(collectionSizeOrDefault($receiver, 10));
    var tmp$_0;
    tmp$_0 = $receiver.iterator();
    while (tmp$_0.hasNext()) {
      var item = tmp$_0.next();
      var tmp$_1 = destination.add_11rb$;
      var array = Array_0(4);
      var tmp$_2;
      tmp$_2 = array.length - 1 | 0;
      for (var i_0 = 0; i_0 <= tmp$_2; i_0++) {
        array[i_0] = new UByte_init(0);
      }
      tmp$_1.call(destination, array);
    }
    var transposedMatrix = copyToArray(destination);
    for (var i_1 = 0; i_1 < 4; i_1++) {
      for (var j = 0; j < 4; j++) {
        transposedMatrix[i_1][j] = this.state[j][i_1];
      }
    }
    var $receiver_0 = this.state;
    var tmp$_3;
    for (tmp$_3 = 0; tmp$_3 !== $receiver_0.length; ++tmp$_3) {
      var element = $receiver_0[tmp$_3];
      this.clearArray_0(element);
    }
    this.completed = true;
    return copyToArray(flatten(transposedMatrix));
  };
  Aes.prototype.decrypt = function () {
    var tmp$;
    if (this.completed) {
      throw RuntimeException_init('Decrypt can only be called once per Aes instance, since the state is cleared at the ' + 'end of the operation');
    }
    this.round = this.numberOfRounds;
    this.printState_0();
    this.inverseAddRoundKey();
    this.printState_0();
    tmp$ = this.numberOfRounds - 1 | 0;
    for (var i = 0; i < tmp$; i++) {
      this.inversShiftRows();
      this.printState_0();
      this.inverseSubBytes();
      this.printState_0();
      this.inverseAddRoundKey();
      this.printState_0();
      this.inverseMixColumns();
      this.printState_0();
    }
    this.inversShiftRows();
    this.printState_0();
    this.inverseSubBytes();
    this.printState_0();
    this.inverseAddRoundKey();
    this.printState_0();
    var $receiver = until(0, 4);
    var destination = ArrayList_init(collectionSizeOrDefault($receiver, 10));
    var tmp$_0;
    tmp$_0 = $receiver.iterator();
    while (tmp$_0.hasNext()) {
      var item = tmp$_0.next();
      var tmp$_1 = destination.add_11rb$;
      var array = Array_0(4);
      var tmp$_2;
      tmp$_2 = array.length - 1 | 0;
      for (var i_0 = 0; i_0 <= tmp$_2; i_0++) {
        array[i_0] = new UByte_init(0);
      }
      tmp$_1.call(destination, array);
    }
    var transposedMatrix = copyToArray(destination);
    for (var i_1 = 0; i_1 < 4; i_1++) {
      for (var j = 0; j < 4; j++) {
        transposedMatrix[i_1][j] = this.state[j][i_1];
      }
    }
    this.printState_1(transposedMatrix);
    var $receiver_0 = this.state;
    var tmp$_3;
    for (tmp$_3 = 0; tmp$_3 !== $receiver_0.length; ++tmp$_3) {
      var element = $receiver_0[tmp$_3];
      this.clearArray_0(element);
    }
    this.completed = true;
    return copyToArray(flatten(transposedMatrix));
  };
  Aes.prototype.clearArray_0 = function (array) {
    var tmp$;
    tmp$ = get_indices(array).iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      array[element] = new UByte_init(0);
    }
  };
  function Aes$printState$lambda$lambda(it) {
    return toString(it, 16);
  }
  Aes.prototype.printState_0 = function () {
    if (!Aes$Companion_getInstance().debug_0) {
      return;
    }
    println_0();
    var $receiver = this.state;
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var element = $receiver[tmp$];
      println(joinToString_0(element, ' ', void 0, void 0, void 0, void 0, Aes$printState$lambda$lambda));
    }
  };
  function Aes$printState$lambda$lambda_0(it) {
    return toString(it, 16);
  }
  Aes.prototype.printState_1 = function (specific) {
    if (!Aes$Companion_getInstance().debug_0) {
      return;
    }
    println_0();
    var tmp$;
    for (tmp$ = 0; tmp$ !== specific.length; ++tmp$) {
      var element = specific[tmp$];
      println(joinToString_0(element, ' ', void 0, void 0, void 0, void 0, Aes$printState$lambda$lambda_0));
    }
  };
  Aes.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'Aes',
    interfaces: []
  };
  function AesKey(key, keyLength) {
    this.key = key;
    this.keyLength = keyLength;
    var $receiver = chunked_0(this.key, 2);
    var destination = ArrayList_init(collectionSizeOrDefault($receiver, 10));
    var tmp$;
    tmp$ = $receiver.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      destination.add_11rb$(toUByte(item, 16));
    }
    this.keyArray = copyToArray(destination);
    this.numberOf32BitWords = this.keyLength / 32 | 0;
    this.checkKeyLength_bm4lxs$(this.key, this.keyLength);
  }
  function AesKey$Aes128Key(key) {
    AesKey.call(this, key, 128);
  }
  AesKey$Aes128Key.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'Aes128Key',
    interfaces: [AesKey]
  };
  function AesKey$Aes192Key(key) {
    AesKey.call(this, key, 192);
  }
  AesKey$Aes192Key.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'Aes192Key',
    interfaces: [AesKey]
  };
  function AesKey$Aes256Key(key) {
    AesKey.call(this, key, 256);
  }
  AesKey$Aes256Key.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'Aes256Key',
    interfaces: [AesKey]
  };
  AesKey.prototype.checkKeyLength_bm4lxs$ = function (key, expectedLength) {
    if ((key.length / 2 | 0) !== (expectedLength / 8 | 0)) {
      throw RuntimeException_init('Invalid key length');
    }
  };
  AesKey.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'AesKey',
    interfaces: []
  };
  function UByteArray$lambda(closure$init) {
    return function (index) {
      return closure$init(index).data;
    };
  }
  var chunked$lambda_2 = wrapFunction(function () {
    var copyToArray = Kotlin.kotlin.collections.copyToArray;
    return function (it) {
      return copyToArray(it);
    };
  });
  function AesCbc(aesKey, mode, initializationVector) {
    AesCbc$Companion_getInstance();
    if (initializationVector === void 0)
      initializationVector = null;
    this.aesKey = aesKey;
    this.mode = mode;
    this.currentOutput = [];
    this.previousEncrypted = [];
    var tmp$;
    var $receiver = initializationVector;
    var tmp$_0 = $receiver == null;
    if (!tmp$_0) {
      tmp$_0 = $receiver.length === 0;
    }
    if (tmp$_0) {
      tmp$ = SRNG_getInstance().getRandomBytes_za3lpa$(16);
    }
     else {
      tmp$ = initializationVector;
    }
    this.initVector = tmp$;
    var list = ArrayList_init(0);
    for (var index = 0; index < 0; index++) {
      list.add_11rb$([]);
    }
    this.output = list;
    this.buffer = toTypedArray(new UByteArray(Kotlin.fillArray(new Int8Array(16), UByteArray$lambda(AesCbc$buffer$lambda))));
    this.bufferCounter = 0;
  }
  function AesCbc$Companion() {
    AesCbc$Companion_instance = this;
    this.BLOCK_BYTES = 16;
  }
  AesCbc$Companion.prototype.createEncryptor_c1slg8$ = function (aesKey) {
    return new AesCbc(aesKey, Mode$ENCRYPT_getInstance());
  };
  AesCbc$Companion.prototype.createDecryptor_c1slg8$ = function (aesKey) {
    return new AesCbc(aesKey, Mode$DECRYPT_getInstance());
  };
  AesCbc$Companion.prototype.encrypt_dx3icu$ = function (aesKey, data) {
    var aesCbc = new AesCbc(aesKey, Mode$ENCRYPT_getInstance());
    aesCbc.addData_ummv9a$(data);
    return aesCbc.encrypt();
  };
  AesCbc$Companion.prototype.decrypt_drkyzd$ = function (aesKey, data, initialCounter) {
    if (initialCounter === void 0)
      initialCounter = null;
    var aesCbc = new AesCbc(aesKey, Mode$DECRYPT_getInstance(), initialCounter);
    aesCbc.addData_ummv9a$(data);
    return aesCbc.decrypt();
  };
  AesCbc$Companion.prototype.padToBlock_0 = function (unpadded) {
    var paddingSize = 16 - unpadded.length | 0;
    if (unpadded.length === 16) {
      return unpadded;
    }
    if (unpadded.length === 16) {
      var array = Array_0(16);
      var tmp$;
      tmp$ = array.length - 1 | 0;
      for (var i = 0; i <= tmp$; i++) {
        array[i] = new UByte_init(toByte(16));
      }
      return array;
    }
    if (unpadded.length > 16) {
      throw IllegalStateException_init('Block larger than 128 bytes');
    }
    var array_0 = Array_0(16);
    var tmp$_0;
    tmp$_0 = array_0.length - 1 | 0;
    for (var i_0 = 0; i_0 <= tmp$_0; i_0++) {
      var init$result;
      if (get_indices(unpadded).contains_mef7kx$(i_0)) {
        init$result = unpadded[i_0];
      }
       else {
        init$result = new UByte_init(toByte(paddingSize));
      }
      array_0[i_0] = init$result;
    }
    return array_0;
  };
  AesCbc$Companion.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'Companion',
    interfaces: []
  };
  var AesCbc$Companion_instance = null;
  function AesCbc$Companion_getInstance() {
    if (AesCbc$Companion_instance === null) {
      new AesCbc$Companion();
    }
    return AesCbc$Companion_instance;
  }
  AesCbc.prototype.addData_ummv9a$ = function (data) {
    if ((this.bufferCounter + data.length | 0) < 16)
      this.appendToBuffer_0(data, this.bufferCounter);
    else if ((this.bufferCounter + data.length | 0) >= 16) {
      var last = data.length % 16;
      var hasLast = last !== 0;
      var numberOfSlices = data.length / 16 | 0;
      var list = ArrayList_init(0);
      for (var index = 0; index < 0; index++) {
        list.add_11rb$(emptyList());
      }
      var result = list;
      for (var i = 0; i < numberOfSlices; i++) {
        result.add_11rb$(slice(data, until(Kotlin.imul(i, 16), Kotlin.imul(i + 1 | 0, 16))));
      }
      if (hasLast) {
        result.add_11rb$(slice(data, until(Kotlin.imul(numberOfSlices, 16), data.length)));
      }
      var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
      var tmp$;
      tmp$ = result.iterator();
      while (tmp$.hasNext()) {
        var item = tmp$.next();
        destination.add_11rb$(copyToArray(item));
      }
      var chunked = copyToArray(destination);
      var tmp$_0;
      for (tmp$_0 = 0; tmp$_0 !== chunked.length; ++tmp$_0) {
        var element = chunked[tmp$_0];
        if ((this.bufferCounter + element.length | 0) < 16) {
          this.appendToBuffer_0(element, this.bufferCounter);
        }
         else {
          arrayCopy(element, this.buffer, this.bufferCounter, 0, 16 - this.bufferCounter | 0);
          var $receiver = this.output;
          var element_0 = this.consumeBlock_0(this.buffer);
          $receiver.add_11rb$(element_0);
          var array = Array_0(16);
          var tmp$_1;
          tmp$_1 = array.length - 1 | 0;
          for (var i_0 = 0; i_0 <= tmp$_1; i_0++) {
            var init$result;
            var tmp$_2;
            tmp$_2 = element.length - (16 - this.bufferCounter) | 0;
            if (0 <= i_0 && i_0 < tmp$_2) {
              init$result = element[i_0 + (16 - this.bufferCounter) | 0];
            }
             else {
              init$result = new UByte_init(0);
            }
            array[i_0] = init$result;
          }
          this.buffer = array;
          this.bufferCounter = element.length - (16 - this.bufferCounter) | 0;
        }
      }
    }
  };
  AesCbc.prototype.encrypt = function () {
    if (this.bufferCounter > 0) {
      var lastBlockPadded = AesCbc$Companion_getInstance().padToBlock_0(this.buffer);
      if (lastBlockPadded.length > 16) {
        var last = lastBlockPadded.length % 16;
        var hasLast = last !== 0;
        var numberOfSlices = lastBlockPadded.length / 16 | 0;
        var list = ArrayList_init(0);
        for (var index = 0; index < 0; index++) {
          list.add_11rb$(emptyList());
        }
        var result = list;
        for (var i = 0; i < numberOfSlices; i++) {
          result.add_11rb$(slice(lastBlockPadded, until(Kotlin.imul(i, 16), Kotlin.imul(i + 1 | 0, 16))));
        }
        if (hasLast) {
          result.add_11rb$(slice(lastBlockPadded, until(Kotlin.imul(numberOfSlices, 16), lastBlockPadded.length)));
        }
        var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
        var tmp$;
        tmp$ = result.iterator();
        while (tmp$.hasNext()) {
          var item = tmp$.next();
          destination.add_11rb$(copyToArray(item));
        }
        var chunks = copyToArray(destination);
        var $receiver = this.output;
        var element = this.consumeBlock_0(chunks[0]);
        $receiver.add_11rb$(element);
        var $receiver_0 = this.output;
        var element_0 = this.consumeBlock_0(chunks[1]);
        $receiver_0.add_11rb$(element_0);
      }
       else {
        var $receiver_1 = this.output;
        var element_1 = this.consumeBlock_0(lastBlockPadded);
        $receiver_1.add_11rb$(element_1);
      }
    }
    var tmp$_0 = reversed(this.output);
    var array = Array_0(0);
    var tmp$_1;
    tmp$_1 = array.length - 1 | 0;
    for (var i_0 = 0; i_0 <= tmp$_1; i_0++) {
      array[i_0] = new UByte_init(0);
    }
    var accumulator = array;
    if (!tmp$_0.isEmpty()) {
      var iterator = tmp$_0.listIterator_za3lpa$(tmp$_0.size);
      while (iterator.hasPrevious()) {
        var arrayOfUBytes = iterator.previous();
        accumulator = accumulator.concat(arrayOfUBytes);
      }
    }
    return new EncryptedDataAndInitializationVector(accumulator, this.initVector);
  };
  AesCbc.prototype.decrypt = function () {
    var tmp$, tmp$_0;
    var removePaddingCount = last_0(last(this.output));
    var other = new UInt(0);
    var tmp$_1 = uintCompare((new UInt(removePaddingCount.data & 255)).data, other.data) > 0;
    if (tmp$_1) {
      var other_0 = new UInt(16);
      tmp$_1 = uintCompare((new UInt(removePaddingCount.data & 255)).data, other_0.data) < 0;
    }
    if (tmp$_1) {
      tmp$ = dropLast(last(this.output), removePaddingCount.data & 255 & 127);
    }
     else {
      tmp$ = toList_0(last(this.output));
    }
    var removedPadding = tmp$;
    var tmp$_2 = copyToArray(dropLast_0(this.output, 1));
    var elements = copyToArray(removedPadding);
    var preparedOutput = tmp$_2.concat(elements);
    var reversed = Kotlin.isType(tmp$_0 = reversed_0(preparedOutput), List) ? tmp$_0 : throwCCE();
    var array = Array_0(0);
    var tmp$_3;
    tmp$_3 = array.length - 1 | 0;
    for (var i = 0; i <= tmp$_3; i++) {
      array[i] = new UByte_init(0);
    }
    var accumulator = array;
    if (!reversed.isEmpty()) {
      var iterator = reversed.listIterator_za3lpa$(reversed.size);
      while (iterator.hasPrevious()) {
        var arrayOfUBytes = iterator.previous();
        accumulator = accumulator.concat(arrayOfUBytes);
      }
    }
    var folded = accumulator;
    return folded;
  };
  AesCbc.prototype.appendToBuffer_0 = function (array, start) {
    arrayCopy(array, this.buffer, start, 0, array.length);
    this.bufferCounter = this.bufferCounter + array.length | 0;
  };
  AesCbc.prototype.consumeBlock_0 = function (data) {
    var tmp$, tmp$_0;
    switch (this.mode.name) {
      case 'ENCRYPT':
        if (this.currentOutput.length === 0) {
          println('IV: ' + this.initVector);
          tmp$ = Aes$Companion_getInstance().encrypt_dx3icu$(this.aesKey, xor(data, this.initVector));
        }
         else {
          tmp$ = Aes$Companion_getInstance().encrypt_dx3icu$(this.aesKey, xor(data, this.currentOutput));
        }

        this.currentOutput = tmp$;
        tmp$_0 = this.currentOutput;
        break;
      case 'DECRYPT':
        if (this.currentOutput.length === 0) {
          this.currentOutput = xor(Aes$Companion_getInstance().decrypt_dx3icu$(this.aesKey, data), this.initVector);
        }
         else {
          this.currentOutput = xor(Aes$Companion_getInstance().decrypt_dx3icu$(this.aesKey, data), this.previousEncrypted);
        }

        this.previousEncrypted = data;
        tmp$_0 = this.currentOutput;
        break;
      default:tmp$_0 = Kotlin.noWhenBranchMatched();
        break;
    }
    return tmp$_0;
  };
  function AesCbc$buffer$lambda(it) {
    return new UByte_init(0);
  }
  AesCbc.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'AesCbc',
    interfaces: []
  };
  function EncryptedDataAndInitializationVector(encryptedData, initilizationVector) {
    this.encryptedData = encryptedData;
    this.initilizationVector = initilizationVector;
  }
  EncryptedDataAndInitializationVector.prototype.equals = function (other) {
    var tmp$, tmp$_0;
    if (this === other)
      return true;
    if (other == null || !((tmp$ = Kotlin.getKClassFromExpression(this)) != null ? tmp$.equals(Kotlin.getKClassFromExpression(other)) : null))
      return false;
    Kotlin.isType(tmp$_0 = other, EncryptedDataAndInitializationVector) ? tmp$_0 : throwCCE();
    if (!contentEquals(this.encryptedData, other.encryptedData))
      return false;
    if (!contentEquals(this.initilizationVector, other.initilizationVector))
      return false;
    return true;
  };
  EncryptedDataAndInitializationVector.prototype.hashCode = function () {
    var result = contentHashCode(this.encryptedData);
    result = (31 * result | 0) + contentHashCode(this.initilizationVector) | 0;
    return result;
  };
  EncryptedDataAndInitializationVector.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'EncryptedDataAndInitializationVector',
    interfaces: []
  };
  EncryptedDataAndInitializationVector.prototype.component1 = function () {
    return this.encryptedData;
  };
  EncryptedDataAndInitializationVector.prototype.component2 = function () {
    return this.initilizationVector;
  };
  EncryptedDataAndInitializationVector.prototype.copy_6a75nw$ = function (encryptedData, initilizationVector) {
    return new EncryptedDataAndInitializationVector(encryptedData === void 0 ? this.encryptedData : encryptedData, initilizationVector === void 0 ? this.initilizationVector : initilizationVector);
  };
  EncryptedDataAndInitializationVector.prototype.toString = function () {
    return 'EncryptedDataAndInitializationVector(encryptedData=' + Kotlin.toString(this.encryptedData) + (', initilizationVector=' + Kotlin.toString(this.initilizationVector)) + ')';
  };
  function UByteArray$lambda_0(closure$init) {
    return function (index) {
      return closure$init(index).data;
    };
  }
  var chunked$lambda_3 = wrapFunction(function () {
    var copyToArray = Kotlin.kotlin.collections.copyToArray;
    return function (it) {
      return copyToArray(it);
    };
  });
  function AesCtr(aesKey, mode, initialCounter) {
    AesCtr$Companion_getInstance();
    if (initialCounter === void 0)
      initialCounter = null;
    this.aesKey = aesKey;
    this.mode = mode;
    this.currentOutput = [];
    this.previousEncrypted = [];
    var tmp$;
    var $receiver = initialCounter;
    var tmp$_0 = $receiver == null;
    if (!tmp$_0) {
      tmp$_0 = $receiver.length === 0;
    }
    if (tmp$_0) {
      tmp$ = SRNG_getInstance().getRandomBytes_za3lpa$(16);
    }
     else {
      tmp$ = initialCounter;
    }
    this.counterStart = tmp$;
    this.blockCounter = AesCtr$Companion_getInstance().modularCreator.fromBigInteger_sao9k6$(BigInteger.Companion.fromUByteArray_6jbb10$(this.counterStart, Endianness.BIG));
    var list = ArrayList_init(0);
    for (var index = 0; index < 0; index++) {
      list.add_11rb$([]);
    }
    this.output = list;
    this.buffer = toTypedArray(new UByteArray(Kotlin.fillArray(new Int8Array(16), UByteArray$lambda_0(AesCtr$buffer$lambda))));
    this.bufferCounter = 0;
  }
  function AesCtr$Companion() {
    AesCtr$Companion_instance = this;
    this.BLOCK_BYTES = 16;
    this.modularCreator = ModularBigInteger.Companion.creatorForModulo_sao9k6$(BigInteger.Companion.ONE.shl_za3lpa$(128).minus_za3lpa$(1));
  }
  AesCtr$Companion.prototype.createEncryptor_c1slg8$ = function (aesKey) {
    return new AesCtr(aesKey, Mode$ENCRYPT_getInstance());
  };
  AesCtr$Companion.prototype.createDecryptor_c1slg8$ = function (aesKey) {
    return new AesCtr(aesKey, Mode$DECRYPT_getInstance());
  };
  AesCtr$Companion.prototype.encrypt_dx3icu$ = function (aesKey, data) {
    var aesCtr = new AesCtr(aesKey, Mode$ENCRYPT_getInstance());
    aesCtr.addData_ummv9a$(data);
    return aesCtr.encrypt();
  };
  AesCtr$Companion.prototype.decrypt_drkyzd$ = function (aesKey, data, initialCounter) {
    if (initialCounter === void 0)
      initialCounter = null;
    var aesCtr = new AesCtr(aesKey, Mode$DECRYPT_getInstance(), initialCounter);
    aesCtr.addData_ummv9a$(data);
    return aesCtr.decrypt();
  };
  AesCtr$Companion.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'Companion',
    interfaces: []
  };
  var AesCtr$Companion_instance = null;
  function AesCtr$Companion_getInstance() {
    if (AesCtr$Companion_instance === null) {
      new AesCtr$Companion();
    }
    return AesCtr$Companion_instance;
  }
  AesCtr.prototype.addData_ummv9a$ = function (data) {
    if ((this.bufferCounter + data.length | 0) < 16)
      this.appendToBuffer_0(data, this.bufferCounter);
    else if ((this.bufferCounter + data.length | 0) >= 16) {
      var last = data.length % 16;
      var hasLast = last !== 0;
      var numberOfSlices = data.length / 16 | 0;
      var list = ArrayList_init(0);
      for (var index = 0; index < 0; index++) {
        list.add_11rb$(emptyList());
      }
      var result = list;
      for (var i = 0; i < numberOfSlices; i++) {
        result.add_11rb$(slice(data, until(Kotlin.imul(i, 16), Kotlin.imul(i + 1 | 0, 16))));
      }
      if (hasLast) {
        result.add_11rb$(slice(data, until(Kotlin.imul(numberOfSlices, 16), data.length)));
      }
      var destination = ArrayList_init(collectionSizeOrDefault(result, 10));
      var tmp$;
      tmp$ = result.iterator();
      while (tmp$.hasNext()) {
        var item = tmp$.next();
        destination.add_11rb$(copyToArray(item));
      }
      var chunked = copyToArray(destination);
      var tmp$_0;
      for (tmp$_0 = 0; tmp$_0 !== chunked.length; ++tmp$_0) {
        var element = chunked[tmp$_0];
        if ((this.bufferCounter + element.length | 0) < 16) {
          this.appendToBuffer_0(element, this.bufferCounter);
        }
         else {
          arrayCopy(element, this.buffer, this.bufferCounter, 0, 16 - this.bufferCounter | 0);
          var $receiver = this.output;
          var element_0 = this.consumeBlock_0(this.buffer, this.blockCounter);
          $receiver.add_11rb$(element_0);
          this.blockCounter = this.blockCounter.plus_za3lpa$(1);
          var array = Array_0(16);
          var tmp$_1;
          tmp$_1 = array.length - 1 | 0;
          for (var i_0 = 0; i_0 <= tmp$_1; i_0++) {
            var init$result;
            var tmp$_2;
            tmp$_2 = element.length - (16 - this.bufferCounter) | 0;
            if (0 <= i_0 && i_0 < tmp$_2) {
              init$result = element[i_0 + (16 - this.bufferCounter) | 0];
            }
             else {
              init$result = new UByte_init(0);
            }
            array[i_0] = init$result;
          }
          this.buffer = array;
          this.bufferCounter = element.length - (16 - this.bufferCounter) | 0;
        }
      }
    }
  };
  AesCtr.prototype.encrypt = function () {
    if (this.bufferCounter > 0) {
      var $receiver = this.output;
      var element = this.consumeBlock_0(this.buffer, this.blockCounter);
      $receiver.add_11rb$(element);
    }
    var tmp$ = reversed(this.output);
    var array = Array_0(0);
    var tmp$_0;
    tmp$_0 = array.length - 1 | 0;
    for (var i = 0; i <= tmp$_0; i++) {
      array[i] = new UByte_init(0);
    }
    var accumulator = array;
    if (!tmp$.isEmpty()) {
      var iterator = tmp$.listIterator_za3lpa$(tmp$.size);
      while (iterator.hasPrevious()) {
        var arrayOfUBytes = iterator.previous();
        accumulator = accumulator.concat(arrayOfUBytes);
      }
    }
    return new EncryptedDataAndInitialCounter(accumulator, this.counterStart);
  };
  AesCtr.prototype.decrypt = function () {
    var tmp$;
    if (this.bufferCounter > 0) {
      var $receiver = this.output;
      var element = this.consumeBlock_0(this.buffer, this.blockCounter);
      $receiver.add_11rb$(element);
    }
    var reversed_0 = Kotlin.isType(tmp$ = reversed(this.output), List) ? tmp$ : throwCCE();
    var array = Array_0(0);
    var tmp$_0;
    tmp$_0 = array.length - 1 | 0;
    for (var i = 0; i <= tmp$_0; i++) {
      array[i] = new UByte_init(0);
    }
    var accumulator = array;
    if (!reversed_0.isEmpty()) {
      var iterator = reversed_0.listIterator_za3lpa$(reversed_0.size);
      while (iterator.hasPrevious()) {
        var arrayOfUBytes = iterator.previous();
        accumulator = accumulator.concat(arrayOfUBytes);
      }
    }
    var folded = accumulator;
    return folded;
  };
  AesCtr.prototype.appendToBuffer_0 = function (array, start) {
    arrayCopy(array, this.buffer, start, 0, array.length);
    this.bufferCounter = this.bufferCounter + array.length | 0;
  };
  AesCtr.prototype.consumeBlock_0 = function (data, blockCount) {
    var tmp$;
    var blockCountAsByteArray = this.expandCounterTo16Bytes_0(blockCount.toUByteArray_1g0qma$(Endianness.BIG));
    switch (this.mode.name) {
      case 'ENCRYPT':
        tmp$ = xor(Aes$Companion_getInstance().encrypt_dx3icu$(this.aesKey, blockCountAsByteArray), data);
        break;
      case 'DECRYPT':
        tmp$ = xor(Aes$Companion_getInstance().encrypt_dx3icu$(this.aesKey, blockCountAsByteArray), data);
        break;
      default:tmp$ = Kotlin.noWhenBranchMatched();
        break;
    }
    return tmp$;
  };
  AesCtr.prototype.expandCounterTo16Bytes_0 = function ($receiver) {
    var tmp$;
    if ($receiver.length < 16) {
      println('Expanding');
      var diff = 16 - $receiver.length | 0;
      var array = Array_0(diff);
      var tmp$_0;
      tmp$_0 = array.length - 1 | 0;
      for (var i = 0; i <= tmp$_0; i++) {
        array[i] = new UByte_init(0);
      }
      var pad = array;
      tmp$ = pad.concat($receiver);
    }
     else {
      tmp$ = $receiver;
    }
    return tmp$;
  };
  function AesCtr$buffer$lambda(it) {
    return new UByte_init(0);
  }
  AesCtr.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'AesCtr',
    interfaces: []
  };
  function EncryptedDataAndInitialCounter(encryptedData, initialCounter) {
    this.encryptedData = encryptedData;
    this.initialCounter = initialCounter;
  }
  EncryptedDataAndInitialCounter.prototype.equals = function (other) {
    var tmp$, tmp$_0;
    if (this === other)
      return true;
    if (other == null || !((tmp$ = Kotlin.getKClassFromExpression(this)) != null ? tmp$.equals(Kotlin.getKClassFromExpression(other)) : null))
      return false;
    Kotlin.isType(tmp$_0 = other, EncryptedDataAndInitializationVector) ? tmp$_0 : throwCCE();
    if (!contentEquals(this.encryptedData, other.encryptedData))
      return false;
    if (!contentEquals(this.initialCounter, other.initilizationVector))
      return false;
    return true;
  };
  EncryptedDataAndInitialCounter.prototype.hashCode = function () {
    var result = contentHashCode(this.encryptedData);
    result = (31 * result | 0) + contentHashCode(this.initialCounter) | 0;
    return result;
  };
  EncryptedDataAndInitialCounter.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'EncryptedDataAndInitialCounter',
    interfaces: []
  };
  EncryptedDataAndInitialCounter.prototype.component1 = function () {
    return this.encryptedData;
  };
  EncryptedDataAndInitialCounter.prototype.component2 = function () {
    return this.initialCounter;
  };
  EncryptedDataAndInitialCounter.prototype.copy_6a75nw$ = function (encryptedData, initialCounter) {
    return new EncryptedDataAndInitialCounter(encryptedData === void 0 ? this.encryptedData : encryptedData, initialCounter === void 0 ? this.initialCounter : initialCounter);
  };
  EncryptedDataAndInitialCounter.prototype.toString = function () {
    return 'EncryptedDataAndInitialCounter(encryptedData=' + Kotlin.toString(this.encryptedData) + (', initialCounter=' + Kotlin.toString(this.initialCounter)) + ')';
  };
  function Mode(name, ordinal) {
    Enum.call(this);
    this.name$ = name;
    this.ordinal$ = ordinal;
  }
  function Mode_initFields() {
    Mode_initFields = function () {
    };
    Mode$ENCRYPT_instance = new Mode('ENCRYPT', 0);
    Mode$DECRYPT_instance = new Mode('DECRYPT', 1);
  }
  var Mode$ENCRYPT_instance;
  function Mode$ENCRYPT_getInstance() {
    Mode_initFields();
    return Mode$ENCRYPT_instance;
  }
  var Mode$DECRYPT_instance;
  function Mode$DECRYPT_getInstance() {
    Mode_initFields();
    return Mode$DECRYPT_instance;
  }
  Mode.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'Mode',
    interfaces: [Enum]
  };
  function Mode$values() {
    return [Mode$ENCRYPT_getInstance(), Mode$DECRYPT_getInstance()];
  }
  Mode.values = Mode$values;
  function Mode$valueOf(name) {
    switch (name) {
      case 'ENCRYPT':
        return Mode$ENCRYPT_getInstance();
      case 'DECRYPT':
        return Mode$DECRYPT_getInstance();
      default:throwISE('No enum constant com.ionspin.kotlin.crypto.symmetric.Mode.' + name);
    }
  }
  Mode.valueOf_61zpoe$ = Mode$valueOf;
  function SRNG() {
    SRNG_instance = this;
    this.counter = 0;
  }
  SRNG.prototype.getRandomBytes_za3lpa$ = function (amount) {
    var array = Array_0(amount);
    var tmp$;
    tmp$ = array.length - 1 | 0;
    for (var i = 0; i <= tmp$; i++) {
      var tmp$_0;
      array[i] = new UByte_init(toByte((tmp$_0 = this.counter, this.counter = tmp$_0 + 1 | 0, tmp$_0)));
    }
    return array;
  };
  SRNG.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'SRNG',
    interfaces: []
  };
  var SRNG_instance = null;
  function SRNG_getInstance() {
    if (SRNG_instance === null) {
      new SRNG();
    }
    return SRNG_instance;
  }
  var package$com = _.com || (_.com = {});
  var package$ionspin = package$com.ionspin || (package$com.ionspin = {});
  var package$kotlin = package$ionspin.kotlin || (package$ionspin.kotlin = {});
  var package$crypto = package$kotlin.crypto || (package$kotlin.crypto = {});
  Object.defineProperty(package$crypto, 'Config', {
    get: Config_getInstance
  });
  package$crypto.hexColumsPrint_mgx7ee$ = hexColumsPrint;
  package$crypto.hexColumsPrint_q387ch$ = hexColumsPrint_0;
  package$crypto.hexColumsPrint_uo2ox1$ = hexColumsPrint_1;
  package$crypto.rotateRight_k13f4a$ = rotateRight;
  package$crypto.rotateRight_hc3rh$ = rotateRight_0;
  package$crypto.xor_h1cpxt$ = xor;
  package$crypto.hexStringToUByteArray_pdl1vz$ = hexStringToUByteArray;
  package$crypto.toHexString_q387ch$ = toHexString;
  var package$hash = package$crypto.hash || (package$crypto.hash = {});
  package$hash.Hash = Hash;
  package$hash.UpdatableHash = UpdatableHash;
  package$hash.StatelessHash = StatelessHash;
  $$importsForInline$$['multiplatform-crypto'] = _;
  Object.defineProperty(Blake2b, 'Companion', {
    get: Blake2b$Companion_getInstance
  });
  var package$blake2b = package$hash.blake2b || (package$hash.blake2b = {});
  package$blake2b.Blake2b_init_9d67ql$ = Blake2b_init;
  package$blake2b.Blake2b = Blake2b;
  Object.defineProperty(Sha256, 'Companion', {
    get: Sha256$Companion_getInstance
  });
  var package$sha = package$hash.sha || (package$hash.sha = {});
  package$sha.Sha256 = Sha256;
  Object.defineProperty(Sha512, 'Companion', {
    get: Sha512$Companion_getInstance
  });
  package$sha.Sha512 = Sha512;
  Object.defineProperty(Aes, 'Companion', {
    get: Aes$Companion_getInstance
  });
  var package$symmetric = package$crypto.symmetric || (package$crypto.symmetric = {});
  package$symmetric.Aes = Aes;
  AesKey.Aes128Key = AesKey$Aes128Key;
  AesKey.Aes192Key = AesKey$Aes192Key;
  AesKey.Aes256Key = AesKey$Aes256Key;
  package$symmetric.AesKey = AesKey;
  Object.defineProperty(AesCbc, 'Companion', {
    get: AesCbc$Companion_getInstance
  });
  package$symmetric.AesCbc = AesCbc;
  package$symmetric.EncryptedDataAndInitializationVector = EncryptedDataAndInitializationVector;
  Object.defineProperty(AesCtr, 'Companion', {
    get: AesCtr$Companion_getInstance
  });
  package$symmetric.AesCtr = AesCtr;
  package$symmetric.EncryptedDataAndInitialCounter = EncryptedDataAndInitialCounter;
  Object.defineProperty(Mode, 'ENCRYPT', {
    get: Mode$ENCRYPT_getInstance
  });
  Object.defineProperty(Mode, 'DECRYPT', {
    get: Mode$DECRYPT_getInstance
  });
  package$symmetric.Mode = Mode;
  Object.defineProperty(package$crypto, 'SRNG', {
    get: SRNG_getInstance
  });
  Blake2b$Companion.prototype.digest_5pksov$ = StatelessHash.prototype.digest_5pksov$;
  Blake2b$Companion.prototype.digest_o2z9gi$ = StatelessHash.prototype.digest_o2z9gi$;
  Sha256$Companion.prototype.digest_5pksov$ = StatelessHash.prototype.digest_5pksov$;
  Sha256$Companion.prototype.digest_o2z9gi$ = StatelessHash.prototype.digest_o2z9gi$;
  Sha512$Companion.prototype.digest_5pksov$ = StatelessHash.prototype.digest_5pksov$;
  Sha512$Companion.prototype.digest_o2z9gi$ = StatelessHash.prototype.digest_o2z9gi$;
  Kotlin.defineModule('multiplatform-crypto', _);
  return _;
}(module.exports, require('kotlin'), require('bignum')));

//# sourceMappingURL=multiplatform-crypto.js.map
